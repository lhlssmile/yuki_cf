# [[GYM105129L] Prime](https://codeforces.com/gym/105129/problem/L)

**提示：** 如何找到与所有数组元素的最大公约数都至少为2的最小正整数？

这是一道数论题，要求找到最小的正整数 m，使得对于数组中的每个元素 ai，都有 gcd(ai, m) ≥ 2。

**核心思路：**

题目的关键在于理解 gcd(ai, m) ≥ 2 的含义：
- gcd(ai, m) ≥ 2 意味着 ai 和 m 至少有一个大于1的公因数
- 换句话说，ai 和 m 不能互质（gcd ≠ 1）

**算法分析：**

1. **预处理阶段**：
   - 生成所有可能的候选答案 to_check
   - 从质数集合 {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47} 开始
   - 通过质数的乘积组合生成所有可能的 m 值
   - 这样确保每个候选 m 都包含足够的质因数

2. **贪心策略**：
   - 按从小到大的顺序检查每个候选 m
   - 对于每个 m，检查是否与数组中所有元素的 gcd 都 ≥ 2
   - 找到第一个满足条件的 m 就是答案

**算法正确性：**

为什么这种预处理方式是正确的？
- 如果 m 与某个 ai 互质，说明它们没有公共的质因数
- 要让 gcd(ai, m) ≥ 2，m 必须包含 ai 的某个质因数
- 由于 ai ≤ 50，所有可能的质因数都在预设的质数集合中
- 通过质数的乘积组合，可以覆盖所有可能的有效 m 值

**时间复杂度分析：**

- 预处理：O(P × 2^P)，其中 P 是质数个数（15个）
- 每个测试用例：O(|to_check| × 50)
- 总体复杂度：O(T × |to_check| × 50)

**空间复杂度：** O(2^P + 50) - 存储候选答案和标记数组

```cpp
// 预处理生成所有候选答案
vi pre = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};
vll to_check = {1};
int prehandle = []() {
    for (int x : pre) {
        int k = to_check.size();
        For(i, k) to_check.pb(x * to_check[i]);
    }
    sort(to_check.begin(), to_check.end());
    return 0;
}();

// 主算法：贪心查找最小满足条件的m
for (auto x : to_check) {
    bool flg = true;
    For(i, 51) {
        if (vis[i] && gcd(i, x) == 1) {  // 如果存在互质的元素
            flg = false;
            break;
        }
    }
    if (flg) {
        cout << x << "\n";
        break;
    }
}
```

**关键观察：**

1. **数据范围限制**：ai ≤ 50，质因数有限
2. **贪心选择**：最小的满足条件的 m 就是最优解
3. **预处理优化**：避免重复计算，提高效率
4. **互质判断**：gcd(ai, m) = 1 当且仅当 ai 和 m 互质

**边界情况：**
- 所有 ai 都是质数：m 必须是这些质数的倍数
- 所有 ai 都是合数：m 可能更小，取决于公共因数
- 单个元素：m 至少是该元素的某个因数的倍数