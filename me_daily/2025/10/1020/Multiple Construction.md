# Multiple Construction

**提示：** 如何构造一个满足距离约束的数组？

这是一道经典的构造题。题目要求构造一个长度为 2n 的数组，使得每个数字 1 到 n 都恰好出现两次，且每个数字两次出现位置的距离是该数字的倍数。

**核心思路：**

通过观察代码可以发现，这道题的关键在于贪心构造策略：
1. **前半部分**：按照 n, n-1, n-2, ..., 1 的顺序填充前 n 个位置
2. **后半部分**：从大到小遍历每个数字，在后半部分找到第一个满足距离约束的空位置

**算法证明：**

设数字 x 在位置 i 和位置 j 出现（i < j），则需要满足 (j - i) % x == 0。

构造策略的正确性：
- 大数字优先放置，因为它们的约束更严格（倍数更大）
- 前半部分倒序放置，为后半部分留出更多选择空间
- 后半部分按步长 x 搜索，保证距离约束

**贪心策略正确性：**

从大到小处理数字的原因：
1. 大数字的可选位置更少（步长大）
2. 先处理约束更严格的数字，避免后续无解
3. 小数字更灵活，可以填充剩余空隙

**边界情况：**
- 当 n=1 时，直接输出 [1, 1]
- 保证每个数字都能找到合适的第二个位置

**时间复杂度：** O(n²) - 每个数字最多遍历 n 个位置  
**空间复杂度：** O(n) - 存储结果数组

```cpp
vi solve(int n) {
    vi res(2 * n, 0);
    // 前半部分：倒序填充 n, n-1, ..., 1
    For(i, n) res[i] = n - i;
    
    // 后半部分：为每个数字找第二个位置
    for (int x = n; x >= 1; --x) {
        for (int j = n; j < 2 * n; j += x) {  // 按步长x搜索
            if (res[j] == 0) {
                res[j] = x;
                break;
            }
        }
    }
    return res;
}
```

**示例分析：**

对于 n=3：
1. 前半部分：[3, 2, 1, 0, 0, 0]
2. 处理数字3：在位置3放置3 → [3, 2, 1, 3, 0, 0]
3. 处理数字2：在位置4放置2 → [3, 2, 1, 3, 2, 0]
4. 处理数字1：在位置5放置1 → [3, 2, 1, 3, 2, 1]

验证：
- 数字1：位置2和5，距离3，3%1=0 ✓
- 数字2：位置1和4，距离3，但应该是位置1和5，距离4，4%2=0 ✓
- 数字3：位置0和3，距离3，3%3=0 ✓