# Clique in the Divisibility Graph

**题目链接**: [Codeforces 566F - Clique in the Divisibility Graph](https://codeforces.com/problemset/problem/566/F)

## 题目理解

给定一个正整数集合 `A = {a1, a2, ..., an}`，构建一个可整除图：
- 图的顶点是集合 `A` 中的数字
- 两个数字 `ai` 和 `aj` 之间有边当且仅当 `ai` 整除 `aj` 或 `aj` 整除 `ai`

求这个可整除图中最大团（clique）的大小。

**团的定义**：图中的一个顶点子集，其中任意两个顶点之间都有边相连。

## 核心观察

**关键洞察**：在可整除图中，一个团对应一个可整除链！

如果数字 `x1, x2, ..., xk` 构成一个团，那么它们之间任意两个都有整除关系。这意味着这些数字可以排列成一个整除链：`x1 | x2 | x3 | ... | xk`（其中 `|` 表示整除）。

因此，**最大团问题转化为最长整除链问题**。

## 算法思路

**动态规划 + 倍数枚举**：

1. `f[x]` 表示以数字 `x` 结尾的最长整除链长度
2. 对于每个存在的数字 `x`，枚举它的所有倍数 `y = 2x, 3x, 4x, ...`
3. 如果倍数 `y` 也在集合中，则更新 `f[y] = max(f[y], f[x] + 1)`

## 算法详解

### 预处理和初始化

```cpp
const int MAX = 1000001;
V<bool> exist(MAX, false);  // 标记哪些数字存在
vi f(MAX, 0);               // f[x] = 以x结尾的最长链长度
int ans = 1;                // 答案至少为1

// 读入数据并标记存在的数字
For(i, n) {
    cin >> a[i];
    exist[a[i]] = true;
}
```

### 动态规划转移

```cpp
FOR(x, 1, MAX) {
    if (!exist[x]) continue;  // 跳过不存在的数字
    
    f[x] = max(f[x], 1);      // 单独一个数字构成长度为1的链
    
    // 枚举x的所有倍数
    for (int y = x * 2; y < MAX; y += x) {
        if (exist[y]) {
            f[y] = max(f[y], f[x] + 1);  // 将y接到以x结尾的链后面
        }
    }
    
    ans = max(ans, f[x]);     // 更新全局答案
}
```

### 转移过程解析

对于每个数字 `x`：
1. **初始化**：`f[x] = 1`（单独成链）
2. **扩展**：枚举 `x` 的所有倍数 `y = kx`（k ≥ 2）
3. **更新**：如果 `y` 存在，则 `f[y] = max(f[y], f[x] + 1)`
4. **维护答案**：`ans = max(ans, f[x])`

## 算法正确性

**为什么从小到大枚举是正确的？**

1. **拓扑序**：整除关系构成偏序关系，从小到大枚举保证了拓扑序
2. **最优子结构**：以 `y` 结尾的最长链 = 以 `y` 的某个因子结尾的最长链 + 1
3. **无后效性**：处理 `x` 时，所有 `x` 的因子都已经处理完毕

**时间复杂度分析**：
- 外层循环：`O(MAX)`
- 内层倍数枚举：对于数字 `x`，枚举 `MAX/x` 个倍数
- 总复杂度：`∑(MAX/x)` for all x ≈ `MAX * log(MAX)` = `O(MAX log MAX)`

## 复杂度分析

- **时间复杂度**：`O(MAX log MAX)` ≈ `O(10^6 log 10^6)` ≈ `O(2×10^7)`
- **空间复杂度**：`O(MAX)` = `O(10^6)`

其中 `MAX = 10^6 + 1` 是数值范围上界。
