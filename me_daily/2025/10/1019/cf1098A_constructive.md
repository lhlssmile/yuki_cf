# Sum in the tree 1098A

**提示：** 如何贪心使得树的和尽可能小？

这是一道经典的树上贪心构造题。题目给出一棵树，其中奇数深度节点的路径和已知，需要构造偶数深度节点的值，使得整棵树的节点值之和最小。

**核心思路：**

对于未知路径和的节点（偶数深度），我们有两种情况：
1. **叶子节点**：直接继承父节点的路径和，节点值为0
2. **非叶子节点**：贪心地取所有子节点路径和的最小值作为自己的路径和

**算法证明：**

设节点u的路径和为s[u]，节点值为val[u]。对于父子关系有：`s[child] = s[parent] + val[child]`

因此：`val[child] = s[child] - s[parent]`

要使树的总和最小，就要使每个节点值最小。对于未知路径和的节点u：
- 如果u是叶子：`val[u] = s[u] - s[parent] = 0`，所以`s[u] = s[parent]`
- 如果u有子节点：为了使子节点值非负，需要`s[u] ≤ min(s[child])`。取等号时子节点值最小，因此贪心取`s[u] = min(s[child])`

**合法性检查：**

构造过程中需要保证`s[u] ≥ s[parent]`（路径和单调递增），否则返回-1。

**时间复杂度：** O(n) - 每个节点访问一次  
**空间复杂度：** O(n) - 存储树结构和路径和

```cpp
void dfs(int u, int p) {
    if (s[u] == -1) {
        if (g[u].empty()) {
            s[u] = s[p];  // 叶子节点继承父节点路径和
        } else {
            ll mn = LLONG_MAX;
            for (int v : g[u]) {
                mn = min(mn, s[v]);  // 取子节点最小路径和
            }
            if (mn < s[p]) {
                bad = true;  // 不满足单调性
                return;
            }
            s[u] = mn;
        }
    }
    ans += s[u] - s[p];  // 累加节点值
    for (int v : g[u]) dfs(v, u);
}
```