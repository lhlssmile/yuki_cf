# Glasses of Solutions

## 题目描述

**原题链接**: [Codeforces Gym 105582 Problem G](https://codeforces.com/gym/105582/problem/G)

你有 n 个玻璃杯，每个杯子里装着盐溶液。对于每个溶液，都已知其总质量和其中含有的盐质量。目标是找出这些 n 个玻璃杯的**非空子集**的数量，使得如果将这些子集中的内容物合并到一个空玻璃杯中，所得到的溶液的盐质量分数正好达到指定的 `a/b`。

### 输入格式
- 第一行：三个整数 `n`, `a`, `b` (2 ≤ n ≤ 35, 0 ≤ a ≤ 10000, max(a,1) ≤ b ≤ 10000, gcd(a,b)=1)
- 接下来 n 行：每行两个整数 `mi`, `ti` (0 ≤ mi ≤ 10000, max(mi,1) ≤ ti ≤ 10000)
  - `mi`: 第 i 个溶液的盐质量
  - `ti`: 第 i 个溶液的总质量

### 输出格式
输出一个整数——实现盐质量分数为 `a/b` 的方案数量。

## 核心思路分析

### 1. 数学建模

假设我们选择了一个子集 S，其中包含的溶液编号为 {i₁, i₂, ..., iₖ}。

合并后的溶液：
- 总盐质量：`M = mi₁ + mi₂ + ... + miₖ`
- 总质量：`T = ti₁ + ti₂ + ... + tiₖ`
- 盐浓度：`M/T`

我们需要满足条件：`M/T = a/b`

### 2. 关键变换

将等式 `M/T = a/b` 进行变换：
```
M/T = a/b
=> M × b = T × a
=> M × b - T × a = 0
```

对于每个溶液 i，定义：
```
vi = mi × b - ti × a
```

那么问题转化为：**找出所有非空子集，使得子集中所有 vi 的和等于 0**。

### 3. 为什么这样变换？

这个变换的巧妙之处在于：
1. **线性化**：将分数条件转化为线性和的条件
2. **整数化**：避免浮点数运算的精度问题
3. **简化计算**：每个溶液只需要计算一个值 vi

## 算法设计

### 1. 暴力解法的问题

直接枚举所有 2ⁿ - 1 个非空子集，时间复杂度 O(2ⁿ)。
当 n = 35 时，2³⁵ ≈ 3.4 × 10¹⁰，显然会超时。

### 2. Meet-in-the-Middle 优化

**核心思想**：将 n 个元素分成两部分，分别枚举，然后合并结果。

#### 分割策略
- 前半部分：k₁ = n/2 个元素
- 后半部分：k₂ = n - k₁ 个元素

#### 算法步骤

1. **预处理前半部分**：
   - 枚举前 k₁ 个元素的所有 2^k₁ 个子集（包括空集）
   - 计算每个子集的 vi 值之和
   - 用哈希表 `mp` 记录每个和值出现的次数

2. **枚举后半部分**：
   - 枚举后 k₂ 个元素的所有 2^k₂ 个子集（包括空集）
   - 计算每个子集的 vi 值之和为 `val`
   - 在哈希表中查找 `-val`，如果存在，说明可以组成和为 0 的组合
   - 累加对应的方案数

3. **处理空集**：
   - 由于题目要求非空子集，需要减去空集的情况
   - 空集对应前后两部分都选空集，只有 1 种情况

#### 时间复杂度分析
- 前半部分枚举：O(2^(n/2))
- 后半部分枚举：O(2^(n/2))
- 哈希表操作：O(1)
- 总时间复杂度：O(2^(n/2))

当 n = 35 时，2^(35/2) = 2^17.5 ≈ 2^18 = 262,144，完全可以接受。

## 代码实现详解

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using umplli = unordered_map<ll, int>;

int main() {
    int n, a, b;
    cin >> n >> a >> b;
    
    // 分割数组
    int k1 = n / 2, k2 = n - k1;
    vector<ll> v1(k1), v2(k2);
    
    // 读取并预处理前半部分
    for(int i = 0; i < k1; i++) {
        int m, t;
        cin >> m >> t;
        v1[i] = (ll)m * b - (ll)t * a;
    }
    
    // 读取并预处理后半部分
    for(int i = 0; i < k2; i++) {
        int m, t;
        cin >> m >> t;
        v2[i] = (ll)m * b - (ll)t * a;
    }
    
    // 枚举前半部分所有子集
    umplli mp;
    for(int mask = 0; mask < (1 << k1); mask++) {
        ll val = 0;
        for(int j = 0; j < k1; j++) {
            if(mask & (1 << j)) {
                val += v1[j];
            }
        }
        mp[val]++;
    }
    
    // 枚举后半部分所有子集
    ll ans = 0;
    for(int mask = 0; mask < (1 << k2); mask++) {
        ll val = 0;
        for(int j = 0; j < k2; j++) {
            if(mask & (1 << j)) {
                val += v2[j];
            }
        }
        
        // 查找互补的值
        auto it = mp.find(-val);
        if(it != mp.end()) {
            ans += it->second;
        }
    }
    
    // 减去空集的情况
    cout << ans - 1 << "\n";
    return 0;
}
```

### 关键实现细节

1. **数据类型选择**：
   - 使用 `long long` 避免整数溢出
   - `mi × b` 和 `ti × a` 的最大值约为 10⁸，在 int 范围内
   - 但多个值相加可能超出 int 范围

2. **位运算枚举**：
   - `mask` 从 0 到 2^k - 1，表示所有可能的子集
   - `mask & (1 << j)` 判断第 j 个元素是否在当前子集中

3. **哈希表优化**：
   - 使用 `unordered_map<ll, int>` 快速查找和计数
   - 键是子集和，值是该和值出现的次数

4. **空集处理**：
   - 前后两部分都选择空集时，和为 0，但这不是有效方案
   - 最终结果需要减 1

## 复杂度分析

### 时间复杂度
- **预处理**: O(n)
- **前半部分枚举**: O(2^(n/2) × n/2)
- **后半部分枚举**: O(2^(n/2) × n/2)
- **总复杂度**: O(n × 2^(n/2))

### 空间复杂度
- **哈希表**: O(2^(n/2))
- **数组存储**: O(n)
- **总复杂度**: O(2^(n/2))

## 算法正确性证明

### 1. 数学等价性

原问题：找子集 S 使得 `(∑mi) / (∑ti) = a/b`

等价于：`(∑mi) × b = (∑ti) × a`

等价于：`∑(mi × b - ti × a) = 0`

等价于：`∑vi = 0`，其中 `vi = mi × b - ti × a`

### 2. 分割完备性

任何一个子集都可以表示为前半部分子集和后半部分子集的并集。
设前半部分子集和为 `sum1`，后半部分子集和为 `sum2`，
则总和为 `sum1 + sum2 = 0`，即 `sum2 = -sum1`。

我们的算法枚举了所有可能的 `sum1` 和 `sum2` 组合，因此不会遗漏任何有效方案。

### 3. 重复计算处理

唯一需要特殊处理的是空集情况：
- 前半部分选空集（sum1 = 0）
- 后半部分选空集（sum2 = 0）
- 满足 sum1 + sum2 = 0，但不是有效的非空子集

因此最终答案需要减 1。

## 测试用例分析

### 示例 1
```
输入：
5 1 2
1 2
1 2  
1 2
1 2
1 4

输出：15
```

**分析**：
- 目标浓度：1/2 = 0.5
- 前4个溶液浓度都是 1/2 = 0.5
- 第5个溶液浓度是 1/4 = 0.25

计算 vi 值：
- v1 = v2 = v3 = v4 = 1×2 - 2×1 = 0
- v5 = 1×2 - 4×1 = -2

有效子集：
- 任选前4个溶液的非空子集：2⁴ - 1 = 15 种
- 包含第5个溶液的子集都无法达到目标浓度

### 示例 2
```
输入：
2 0 1
0 1
1 1

输出：1
```

**分析**：
- 目标浓度：0/1 = 0
- 第1个溶液：纯水，浓度 0
- 第2个溶液：纯盐，浓度 1

计算 vi 值：
- v1 = 0×1 - 1×0 = 0
- v2 = 1×1 - 1×0 = 1

有效子集：只有选择第1个溶液，v1 = 0，满足条件。
