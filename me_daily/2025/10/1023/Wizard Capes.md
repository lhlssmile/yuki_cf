# The Ancient Wizards' Capes

## 题目描述

**原题链接**: [Codeforces 2155C - The Ancient Wizards' Capes](https://codeforces.com/problemset/problem/2155/C)

有 n 个巫师排成一行，编号从 1 到 n。每个巫师都有一件隐身斗篷，可以穿在左侧或右侧。Harry 从巫师 1 的位置走到巫师 n 的位置，记录从每个巫师位置能看到多少个巫师。

### 可见性规则
巫师 j 从位置 i 可见当且仅当：
- 巫师 j 的斗篷穿在左侧且 i ≥ j
- 巫师 j 的斗篷穿在右侧且 i ≤ j
- 特别地，巫师 i 从位置 i 总是可见的

### 输入格式
- 第一行：测试用例数 t (1 ≤ t ≤ 10⁴)
- 每个测试用例：
  - 第一行：整数 n (1 ≤ n ≤ 10⁵)
  - 第二行：n 个整数 a₁, a₂, ..., aₙ (1 ≤ aᵢ ≤ n)

### 输出格式
对每个测试用例，输出满足条件的斗篷安排方案数，模 676767677。

## 核心思路分析

### 1. 问题建模

设 xᵢ 表示巫师 i 的斗篷状态：
- xᵢ = 0：斗篷穿在左侧
- xᵢ = 1：斗篷穿在右侧

从位置 i 能看到的巫师数量 aᵢ 可以表示为：
```
aᵢ = (左侧可见巫师数) + (右侧可见巫师数) + 1
```

具体地：
- 左侧可见：位置 1 到 i-1 中斗篷穿在左侧的巫师数量
- 右侧可见：位置 i+1 到 n 中斗篷穿在右侧的巫师数量
- +1：巫师 i 自己总是可见

### 2. 关键观察

**相邻位置的关系**：
```
aᵢ - aᵢ₊₁ = (从i能看到但从i+1看不到的) - (从i+1能看到但从i看不到的)
```

分析可得：
- 如果 xᵢ = 0（左侧），从 i+1 位置就看不到巫师 i
- 如果 xᵢ₊₁ = 1（右侧），从 i 位置就能看到巫师 i+1

因此：**aᵢ - aᵢ₊₁ = 1 - xᵢ - xᵢ₊₁**

变形得到：**xᵢ + xᵢ₊₁ = 1 - (aᵢ - aᵢ₊₁)**

### 3. 算法设计

#### 步骤1：计算约束条件
对于每个相邻对 (i, i+1)，计算：
```
sᵢ = xᵢ + xᵢ₊₁ = 1 - (aᵢ - aᵢ₊₁)
```

如果 sᵢ < 0 或 sᵢ > 2，则无解。

#### 步骤2：枚举起始状态
由于 x₁ 只能是 0 或 1，我们枚举这两种情况：

**情况1：x₁ = 0**
- 根据 s₁ = x₁ + x₂，得到 x₂ = s₁ - x₁ = s₁ - 0 = s₁
- 根据 s₂ = x₂ + x₃，得到 x₃ = s₂ - x₂
- 依此类推...

**情况2：x₁ = 1**
- 类似地递推计算所有 xᵢ

#### 步骤3：验证最后一个约束
计算得到所有 xᵢ 后，验证：
```
aₙ = 1 + ∑(i=1 to n-1) xᵢ
```

如果等式成立，则该方案有效。

## 代码实现详解

```python
MOD = 676767677

def solve(n, a):
    # 特殊情况：只有一个巫师
    if n == 1:
        return 2 if a[0] == 1 else 0
    
    # 计算相邻约束 s[i] = x[i] + x[i+1]
    s = []
    for i in range(n-1):
        d = a[i] - a[i+1]
        si = 1 - d
        if si < 0 or si > 2:
            return 0  # 无解
        s.append(si)
    
    ways = 0
    
    # 枚举 x[0] 的两种可能值
    for start in [0, 1]:
        x = [0] * n
        x[0] = start
        valid = True
        
        # 根据约束递推计算所有 x[i]
        for i in range(n-1):
            next_x = s[i] - x[i]
            if next_x not in (0, 1):
                valid = False
                break
            x[i+1] = next_x
        
        if valid:
            # 验证最后一个约束：a[n-1] = 1 + sum(x[0:n-1])
            S = sum(x[:n-1])  # 前n-1个x的和
            implied_an = 1 + S
            if implied_an == a[n-1]:
                ways += 1
    
    return ways % MOD
```

### 关键实现细节

1. **边界检查**：
   - `si < 0 or si > 2`：由于 xᵢ ∈ {0,1}，所以 xᵢ + xᵢ₊₁ ∈ {0,1,2}
   - `next_x not in (0, 1)`：确保计算出的 xᵢ 值合法

2. **最终验证**：
   - 只验证前 n-1 个 x 值的和，因为 xₙ 不影响任何 aᵢ 的计算
   - `implied_an = 1 + S`：根据公式计算期望的 aₙ 值

3. **特殊情况**：
   - n=1 时，只有巫师自己可见，所以 a₁ = 1，有两种斗篷穿法

## 复杂度分析

### 时间复杂度
- 计算约束：O(n)
- 枚举起始状态：O(2) × O(n) = O(n)
- **总复杂度**：O(n)

### 空间复杂度
- 存储约束数组 s：O(n)
- 存储状态数组 x：O(n)
- **总复杂度**：O(n)

## 测试用例分析

### 示例1：n=4, a=[4,4,3,2]

**计算约束**：
- s₁ = 1 - (4-4) = 1
- s₂ = 1 - (4-3) = 0  
- s₃ = 1 - (3-2) = 0

**枚举 x₁ = 0**：
- x₁ = 0, x₂ = 1-0 = 1, x₃ = 0-1 = -1 ❌（无效）

**枚举 x₁ = 1**：
- x₁ = 1, x₂ = 1-1 = 0, x₃ = 0-0 = 0, x₄ = 0-0 = 0
- 验证：a₄ = 1 + (1+0+0) = 2 ✓

**结果**：1种方案

### 示例2：n=1, a=[1]

**特殊情况**：a₁ = 1，符合条件，有2种斗篷穿法。

## 算法正确性证明

### 1. 约束推导的正确性

从位置 i 和 i+1 的可见性差异分析：
- 巫师 i：从位置 i 可见，从位置 i+1 不可见（当 xᵢ = 0 时）
- 巫师 i+1：从位置 i 不可见，从位置 i+1 可见（当 xᵢ₊₁ = 1 时）

因此 aᵢ - aᵢ₊₁ = (1-xᵢ) - xᵢ₊₁ = 1 - xᵢ - xᵢ₊₁

### 2. 枚举完备性

由于 x₁ ∈ {0,1}，枚举这两种情况能覆盖所有可能的解。
每种情况下，后续的 xᵢ 值由约束唯一确定。

### 3. 最终验证的必要性

前 n-1 个约束只能确定 x₁, x₂, ..., xₙ₋₁ 的关系，
但 xₙ 的值不受这些约束限制。
因此需要用 aₙ 的值来验证整个方案的正确性。

## 总结

这道题的精髓在于：

1. **数学建模**：将可见性问题转化为线性约束系统
2. **约束分析**：利用相邻位置的可见性差异建立递推关系
3. **枚举优化**：只需枚举起始状态，后续状态由约束确定
4. **边界处理**：正确处理特殊情况和无效状态

