# Next Beautiful Number

## 题目描述

**LeetCode 2048 - 下一个更大的数值平衡数**

如果整数 `x` 满足：对于每个数位 `d`，这个数位**恰好**在 `x` 中出现 `d` 次。那么整数 `x` 就是一个**数值平衡数**。

给你一个整数 `n`，请你返回**严格大于** `n` 的**最小数值平衡数**。

**示例：**
- 输入：`n = 1` → 输出：`22`（数字2出现2次）
- 输入：`n = 1000` → 输出：`1333`（数字1出现1次，数字3出现3次）
- 输入：`n = 3000` → 输出：`3133`

**约束：** `0 <= n <= 10^6`

## 核心思路分析

### 1. 问题理解与建模

**数值平衡数的定义：**
- 对于数字中的每个数位 `d`（1-9），该数位在整个数字中的出现次数必须恰好等于 `d`
- 数字0不能出现（因为0出现0次是矛盾的）
- 例如：`1333` → 数字1出现1次✓，数字3出现3次✓

**关键观察：**
1. **无0约束**：数值平衡数不能包含数字0
2. **频次匹配**：每个出现的数位 `d` 必须出现恰好 `d` 次
3. **搜索策略**：从 `n+1` 开始逐一检查，找到第一个满足条件的数

### 2. 算法设计

**暴力搜索 + 验证函数：**
```cpp
int x = n + 1;
while (true) {
    if (isBalanced(x)) return x;
    x++;
}
```

**验证函数 `isBalanced(x)`：**
1. 转换为字符串，检查是否包含'0'
2. 统计每个数位的出现频次
3. 验证：对于数位 `i`（1-9），频次要么为0，要么恰好为 `i`

## C++ 代码实现详解

```cpp
auto isBalanced = [](int n) -> bool {
    string s = to_string(n);
    // 1. 检查是否包含数字0
    if (s.find('0') != string::npos) return false;
    
    // 2. 统计每个数位的频次
    vi f(10, 0);
    For(i, s.size()) f[s[i] - '0']++;
    
    // 3. 验证平衡条件：f[i] == 0 或 f[i] == i
    FOR(i, 1, 10) {
        if (f[i] != i && f[i] != 0) return false;
    }
    return true;
};

int main() {
    int n; cin >> n;
    int x = n + 1;
    while (true) {
        if (isBalanced(x)) {
            cout << x;
            break;
        }
        x++;
    }
    return 0;
}
```

### 代码关键点：

1. **Lambda函数**：`isBalanced` 封装验证逻辑，提高代码可读性
2. **字符串转换**：`to_string(n)` 便于逐位分析
3. **频次数组**：`vi f(10, 0)` 统计0-9每个数位的出现次数
4. **双重条件**：`f[i] != i && f[i] != 0` 确保要么不出现，要么出现恰好i次

## 复杂度分析

**时间复杂度：** `O(k * log k)`
- `k` 是从 `n+1` 到答案的距离
- 每次验证需要 `O(log x)` 时间（x的位数）
- 由于数值平衡数相对稀少，k通常较小

**空间复杂度：** `O(log x)`
- 主要是字符串转换和频次数组的空间

## 算法正确性证明

### 1. 终止性保证
- 数值平衡数是无限的（如22, 1333, 3133, 122333, ...）
- 暴力搜索必然能找到第一个大于n的平衡数

### 2. 验证函数正确性
- **无0检查**：`s.find('0') != string::npos` 确保不含0
- **频次统计**：`f[s[i] - '0']++` 准确计算每位出现次数
- **平衡验证**：`f[i] != i && f[i] != 0` 涵盖所有情况

### 3. 最小性保证
- 从 `n+1` 开始递增搜索，第一个找到的必然是最小的

## 测试用例分析

### 测试用例1：`n = 1`
- 检查：2（不平衡，2出现1次≠2）
- 检查：3-21（都不平衡）
- 检查：22（平衡！2出现2次）
- **输出：22** ✓

### 测试用例2：`n = 1000`
- 跳过包含0的数（1001, 1002, ...）
- 检查1111（不平衡，1出现4次≠1）
- 检查1222（不平衡，1出现1次✓，2出现3次≠2）
- 检查1333（平衡！1出现1次✓，3出现3次✓）
- **输出：1333** ✓

### 边界情况：
- `n = 0`：输出22（最小的数值平衡数）
- `n = 21`：输出22
- 大数情况：算法依然有效，但搜索时间可能较长

## 优化思路

### 1. 预计算优化
- 可以预先生成所有可能的数值平衡数（在给定范围内）
- 使用二分查找找到第一个大于n的数

### 2. 构造法优化
- 分析数值平衡数的结构规律
- 直接构造而非暴力搜索

### 3. 剪枝优化
- 如果当前数包含0，可以跳到下一个不包含0的数
- 如果某位频次已经超过该位值，可以提前终止

## 算法标签

**Tags:** `暴力搜索` `数学` `字符串处理` `频次统计` `模拟`

**难度:** Medium

**关键技巧:** 数位分析 + 频次验证 + 线性搜索