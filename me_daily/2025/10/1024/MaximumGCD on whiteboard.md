# Maximum GCD on Whiteboard

**题目来源**: Codeforces 2156C   
**标签**: `贪心` `数学` `GCD` `频次统计` `前缀和`

## 题目描述

给定一个整数 k 和 n 个正整数 a₁, a₂, ..., aₙ 写在白板上，其中 1 ≤ aᵢ ≤ n。你可以执行以下操作：

1. **擦除操作**: 从白板上选择一个整数并擦除它。此操作最多可以执行 k 次。
2. **分割操作**: 从白板上选择一个整数 x ≥ 3。将其分割为三个正整数 x₁, x₂, x₃，使得 x₁ + x₂ + x₃ = x，且 1 ≤ x₁ ≤ x₂ ≤ x₃。然后从白板上擦除 x，并写入两个新整数 x₁ 和 x₃。注意 x₂ 被丢弃。此操作可以执行任意次数。

一个整数集合 b 的美丽值定义为所有元素的最大公约数（GCD）。

你的任务是确定在执行最多 k 次擦除操作和任意次数分割操作后，白板上整数的最大可能美丽值。

## 核心思路分析

### 问题理解与建模

1. **目标**: 最大化剩余数字的 GCD
2. **约束**: 最多 k 次擦除操作，无限次分割操作
3. **关键洞察**: 分割操作可以将大数变成小数，但不能改变数字的因子结构

### 算法设计

**核心思想**: 枚举可能的 GCD 值 d，检查是否能通过操作达到该 GCD。

对于每个候选 GCD 值 d：
1. **有用数字**: d, 2d, 3d（通过分割大数可以得到）
2. **无用数字**: 所有其他 ≤ 4d-1 的数字（需要擦除）
3. **大数字**: > 4d-1 的数字（可以通过分割变成有用数字）

**关键观察**: 
- 任何 ≥ 4d 的数字都可以通过分割得到 d 的倍数
- 数字 x ≥ 4d 可以分割为 (d, d, x-2d)，其中 x-2d ≥ 2d
- 因此我们保留 d 和 x-2d，都是 d 的倍数

## C++ 代码实现详解

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        
        // 统计每个数字的频次
        vector<int> freq(n+1, 0);
        for (int i = 0; i < n; i++) {
            freq[a[i]]++;
        }
        
        // 计算前缀和，用于快速查询 ≤ x 的数字个数
        vector<int> prefix(n+1, 0);
        for (int i = 1; i <= n; i++) {
            prefix[i] = prefix[i-1] + freq[i];
        }
        
        int ans = 1;
        // 从大到小枚举可能的 GCD 值
        for (int d = n; d >= 1; d--) {
            // 计算需要擦除的数字个数
            long long up = min((long long)n, 4LL * d - 1);
            int num_small = prefix[up];  // ≤ 4d-1 的数字个数
            
            // 计算有用的小数字个数（d, 2d, 3d）
            int num_small_good = 0;
            for (int m = 1; m <= 3; m++) {
                long long val = (long long)m * d;
                if (val > n) break;
                num_small_good += freq[val];
            }
            
            // 需要擦除的数字个数
            int cost = num_small - num_small_good;
            
            if (cost <= k) {
                ans = d;
                break;
            }
        }
        
        cout << ans << "\n";
    }
    return 0;
}
```

### 代码关键部分解析

1. **频次统计**: `freq[i]` 记录数字 i 的出现次数
2. **前缀和**: `prefix[i]` 记录 ≤ i 的数字总个数
3. **枚举 GCD**: 从大到小枚举，找到第一个可行的 d
4. **成本计算**: 
   - `num_small`: ≤ 4d-1 的数字个数
   - `num_small_good`: 其中有用的数字个数（d, 2d, 3d）
   - `cost`: 需要擦除的数字个数

## 复杂度分析

- **时间复杂度**: O(n²)
  - 外层循环 O(n)：枚举 GCD 值
  - 内层循环 O(1)：计算成本（最多检查 3 个倍数）
  - 预处理 O(n)：频次统计和前缀和
- **空间复杂度**: O(n)
  - 频次数组和前缀和数组

## 算法正确性证明

### 分割操作的有效性

**引理**: 任何 x ≥ 4d 都可以通过分割得到 d 的倍数。

**证明**: 
- 将 x 分割为 (d, d, x-2d)
- 由于 x ≥ 4d，所以 x-2d ≥ 2d ≥ d
- 满足 1 ≤ d ≤ d ≤ x-2d 的约束
- 保留 d 和 x-2d，都是 d 的倍数

### 贪心策略的正确性

**策略**: 从大到小枚举 GCD 值，找到第一个可行的。

**正确性**: 
- 如果 GCD = d 可行，那么更大的 GCD 值要么不可行，要么需要更多擦除操作
- 我们的目标是最大化 GCD，所以第一个可行的就是最优解
