# Make It Zigzag

**题目链接**: [Codeforces 2154B - Make It Zigzag](https://codeforces.com/contest/2154/problem/B)

## 题目理解

给定长度为 `n` 的正整数数组 `a`，目标是通过最少的操作2次数使数组变成 "awesome" 数组。

**Awesome 数组定义**：对于所有 `i` (1 ≤ i < m)：
- 如果 `i` 是奇数，则 `b[i] < b[i+1]`
- 如果 `i` 是偶数，则 `b[i] > b[i+1]`
- 即：`b[1] < b[2] > b[3] < b[4] > ...` （锯齿状）

**可用操作**：
1. **操作1**：选择位置 `i`，将 `a[i]` 替换为前缀最大值 `max(a[1], ..., a[i])`
2. **操作2**：选择位置 `i`，将 `a[i]` 减1

目标：最小化操作2的使用次数。

## 核心思路

**前缀最大值 + 贪心策略**：

关键观察：
1. 操作1可以将任意位置设为其前缀最大值，且不消耗"成本"
2. 只有奇数位置需要被优化（因为锯齿模式中奇数位置是"谷"）
3. 对于每个奇数位置，我们需要找到它能达到的最大合法值

## 算法详解

### 前缀最大值预处理

```cpp
vector<long long> M(n+1);
M[1] = a[1];
for(int i=2; i<=n; i++) M[i] = max(M[i-1], a[i]);
```

`M[i]` 表示位置 `i` 的前缀最大值，即 `max(a[1], a[2], ..., a[i])`。

### 奇数位置处理策略

对于每个奇数位置 `i`，我们需要确定其最大合法值：

```cpp
for(int i=1; i<=n; i+=2) {  // 遍历所有奇数位置
    if(i == n) {  // 最后一个位置（奇数）
        long long U = M[n-1] - 1;
        long long bi = min(a[n], max(0LL, U));
        ans += a[n] - bi;
    } else if(i == 1) {  // 第一个位置
        long long U = M[2] - 1;
        long long bi = min(a[1], max(0LL, U));
        ans += a[1] - bi;
    } else {  // 中间奇数位置
        long long U = min(M[i-1], M[i+1]) - 1;
        long long bi = min(a[i], max(0LL, U));
        ans += a[i] - bi;
    }
}
```

### 三种情况分析

1. **第一个位置 (i=1)**：
   - 约束：`a[1] < a[2]`
   - 最大合法值：`min(M[2] - 1, a[1])`
   - 通过操作1，`a[2]` 最大可以是 `M[2]`

2. **最后位置 (i=n, n为奇数)**：
   - 约束：`a[n-1] > a[n]`
   - 最大合法值：`min(M[n-1] - 1, a[n])`
   - 通过操作1，`a[n-1]` 最大可以是 `M[n-1]`

3. **中间奇数位置**：
   - 约束：`a[i-1] > a[i] < a[i+1]`
   - 最大合法值：`min(min(M[i-1], M[i+1]) - 1, a[i])`
   - 两边的偶数位置都可以通过操作1达到各自的前缀最大值

## 算法正确性

**为什么只处理奇数位置？**
- 在锯齿模式中，奇数位置是"谷"（需要小于相邻元素）
- 偶数位置是"峰"（需要大于相邻元素），可以通过操作1无成本地增大

**贪心策略的正确性**：
- 对于每个奇数位置，我们计算其在满足约束条件下的最大可能值
- 通过操作1，相邻的偶数位置可以达到其前缀最大值
- 因此每个奇数位置的上界是相邻偶数位置前缀最大值减1

## 复杂度分析

- **时间复杂度**：`O(n)` - 预处理前缀最大值 + 遍历奇数位置
- **空间复杂度**：`O(n)` - 存储前缀最大值数组

## 关键观察

1. **操作1的作用**：可以"免费"地将任意位置设为其前缀最大值
2. **锯齿模式特性**：只有奇数位置需要被"压低"，偶数位置可以任意增大
3. **约束传播**：每个奇数位置的上界由其相邻偶数位置的前缀最大值决定
4. **边界处理**：首尾位置只有一个相邻约束

## 实现细节

- 使用1索引处理，更符合题目描述
- 前缀最大值预处理避免重复计算
- `max(0LL, U)` 确保不会出现负数
- 分情况处理首、尾、中间位置的不同约束