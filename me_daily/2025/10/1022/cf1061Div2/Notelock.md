# Notelock

**题目链接**: [Codeforces 2154A - Notelock](https://codeforces.com/contest/2154/problem/A)

## 题目理解

这是一个关于二进制字符串保护的博弈问题。给定长度为 `n` 的二进制字符串 `s` 和正整数 `k`，游戏规则如下：

1. 首先选择一些位置进行保护
2. 然后 Teto 按顺序从左到右遍历每个位置 `i`，如果满足以下条件，她可以将 `s[i]` 设为 `0`：
   - `s[i] = 1`
   - `s[i]` 没有被保护
   - 前 `k-1` 个元素中不包含 `1`（即 `s[max(1, i-k+1)]` 到 `s[i-1]` 中没有 `1`）

目标是找到最少需要保护多少个位置才能强制 Teto 无法改变字符串。

## 核心思路

**贪心策略 + 间距控制**：

关键观察：如果两个 `1` 之间的距离小于 `k`，那么后面的 `1` 就无法被 Teto 改变（因为前 `k-1` 个元素中包含 `1`）。

因此，我们只需要保护那些与前一个有效 `1` 距离 ≥ `k` 的 `1`。

## 算法详解

### 贪心选择策略

```cpp
int solve(string &s, int k) {
    int n = s.size();
    int ans = 0;
    int last = -k;  // 上一个有效1的位置，初始化为-k确保第一个1会被保护
    
    for (int i = 0; i < n; ++i) {
        if (s[i] == '1') {
            if (i - last >= k) {
                // 这个1与前一个有效1距离太远，需要保护它
                ++ans;
                last = i;  
            } else {
                // 距离近，不需要保护，但它也能起到"阻挡"作用
                last = i;
            }
        }
    }
    return ans;
}
```

### 算法步骤

1. **初始化**：`last = -k` 确保第一个遇到的 `1` 一定会被保护
2. **遍历字符串**：对每个位置 `i`
   - 如果 `s[i] == '1'`：
     - 如果 `i - last >= k`：说明这个 `1` 与上一个有效 `1` 距离太远，Teto 可以将其改为 `0`，所以需要保护
     - 否则：这个 `1` 受到前面 `1` 的保护，不需要额外保护，但更新 `last` 位置

## 算法正确性

**贪心选择的正确性**：
- 如果两个 `1` 之间距离 < `k`，后面的 `1` 自动受保护
- 如果距离 ≥ `k`，后面的 `1` 必须被保护，否则会被 Teto 改变
- 贪心地选择最少的保护位置，每次只在必要时保护

**边界处理**：
- `last = -k` 确保第一个 `1` 总是被保护（因为 `0 - (-k) = k ≥ k`）

## 复杂度分析

- **时间复杂度**：`O(n)` - 单次遍历字符串
- **空间复杂度**：`O(1)` - 只使用常数额外空间

## 关键观察

1. **间距控制**：关键在于理解 `k` 的作用 - 它定义了 `1` 之间的"影响范围"
2. **贪心策略**：总是在必要时才保护，利用已有的 `1` 来保护后续的 `1`
3. **状态维护**：`last` 记录最近的有效 `1` 位置，用于判断当前 `1` 是否需要保护

## 实现细节

- 使用 `last` 变量追踪最近的有效 `1` 位置
- 初始化 `last = -k` 处理边界情况
- 每遇到 `1` 都更新 `last`，无论是否需要保护