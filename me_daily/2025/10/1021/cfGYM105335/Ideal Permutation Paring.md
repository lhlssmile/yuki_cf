# Ideal Permutation Paring

## 题目链接
[Codeforces GYM 105335 - Ideal Permutation Paring](https://codeforces.com/gym/105335/problem/I)

## 题目理解

给定一个大小为 N 的排列 p，需要找到另一个排列 q，使得 p 和 q 构成一个「理想对」。

**理想对的定义**：当所有 N! 个排列按字典序排列成一个圆圈时，排列 p 和排列 q 在圆圈中正好相对（即它们之间相隔 N!/2 个位置）。

## 核心思路

### 1. 排列的字典序编号

对于一个排列，我们可以计算它在所有排列的字典序中的位置（从0开始编号）。设排列 p 的编号为 `index_p`，那么与它构成理想对的排列 q 的编号为：
```
index_q = (index_p + N!/2) % N!
```

### 2. 排列编号的计算

对于排列 `[a1, a2, ..., an]`，其字典序编号为：
```
index = (a1-1) * (n-1)! + (a2-1-count) * (n-2)! + ...
```
其中 `count` 是在 a2 前面且小于 a2 的元素个数。

### 3. 从编号还原排列

给定编号 `index`，可以通过以下方式还原排列：
1. 第一个位置：`pos1 = index / (n-1)! + 1`
2. 剩余编号：`remaining = index % (n-1)!`
3. 递归处理剩余位置

## 算法详解

### 步骤1：计算前两个位置的对应关系

```cpp
vector<long long> tmp = {nums[0] - 1, nums[1] - 1};
if (tmp[1] > tmp[0]) tmp[1] --;
```

这里处理原排列前两个位置的编号贡献：
- `nums[0] - 1`：第一个位置的贡献
- `nums[1] - 1`：第二个位置的原始值
- 如果 `nums[1] > nums[0]`，需要减1，因为 `nums[0]` 已经被使用

### 步骤2：计算目标排列的前两个位置

```cpp
tmp[1] += 1ll * n * (n - 1) / 2;  // 加上 N!/2
tmp[0] += tmp[1] / (n - 1);       // 进位处理
tmp[1] %= n - 1;                  // 取余
tmp[0] %= n;                      // 第一位取余
```

这里实现了 `(index + N!/2) % N!` 的计算：
- `N!/2 = N * (N-1)!/2`
- 通过进位和取余操作得到目标排列的前两个位置

### 步骤3：还原实际的排列值

```cpp
vector<long long> ans = {tmp[0] + 1, tmp[1] + 1};
if (ans[1] >= ans[0]) ans[1] ++;
```

将编号转换回实际的排列值，并处理第二个位置的调整。

### 步骤4：构建剩余位置的映射

```cpp
vector<int> vis1(n + 1, 0), vis2(n + 1, 1);

// 标记原排列中剩余的元素
for (int i = 2; i < n; i ++)
    vis1[nums[i]] = 1;

// 标记目标排列中已使用的元素
for (auto &x: ans)
    vis2[x] = 0;

// 建立映射关系
vector<int> mapping(n + 1, 0);
int p1 = 1, p2 = 1;

for (int _ = 0; _ < n - 2; _ ++) {
    while (!vis1[p1]) p1 ++;
    while (!vis2[p2]) p2 ++;
    mapping[p1 ++] = p2 ++;
}
```

这里建立了原排列剩余元素到目标排列剩余元素的一一对应关系。

### 步骤5：构造完整的目标排列

```cpp
for (int i = 2; i < n; i ++)
    ans.emplace_back(mapping[nums[i]]);
```

## 算法正确性

1. **前两位的处理**：通过精确的数学计算，确保了字典序编号的正确性
2. **剩余位置的映射**：保证了排列的完整性和唯一性
3. **理想对的性质**：通过 `(index + N!/2) % N!` 确保了两个排列在圆圈中正好相对

## 复杂度分析

- **时间复杂度**：O(N)，主要是遍历和映射构建
- **空间复杂度**：O(N)，用于存储各种数组和映射关系

## 关键观察

1. **数学转换**：将几何问题（圆圈中的相对位置）转化为数学问题（字典序编号的计算）
2. **分治思想**：将排列分为前两位和后续位置分别处理
3. **映射构建**：通过双指针技术建立剩余元素的对应关系

## 实现细节

- 使用 `long long` 避免整数溢出
- 通过 `vis1` 和 `vis2` 数组高效地管理元素的使用状态
- 双指针技术确保映射关系的正确性和效率

这道题巧妙地结合了排列的字典序性质、模运算和构造算法，是一道很好的数学+构造题目。