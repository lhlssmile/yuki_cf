# Incremental Subarray

## 题目链接
[Codeforces 2151A - Incremental Subarray](https://codeforces.com/problemset/problem/2151/A)

## 题目理解

给定一个数组 b，它是由以下方式构造的：
- 对于每个 i 从 1 到 n，将子数组 [1, 2, ..., i] 添加到 b 的末尾
- 例如：n=3 时，b = [1, 1,2, 1,2,3]

现在给定一个子序列 fsb（从 b 中选取的），问有多少种方式可以从 b 中选出这个子序列。

## 核心思路

### 1. 构造数组 b 的规律

对于 n=6，构造的数组 b 为：
```
b = [1, 1,2, 1,2,3, 1,2,3,4, 1,2,3,4,5, 1,2,3,4,5,6]
```

每个数字 x 在数组 b 中的出现次数：
- 数字 1：出现 n 次（在每个子数组中都出现）
- 数字 2：出现 n-1 次
- 数字 x：出现 n-x+1 次

### 2. 子序列匹配的关键观察

给定子序列 fsb，我们需要判断：
1. **如果 fsb 是严格递增的**：那么它可以匹配到多个不同的位置
2. **如果 fsb 不是严格递增的**：那么只能有一种匹配方式

### 3. 严格递增序列的计数

如果子序列 fsb = [a1, a2, ..., am] 是严格递增的（即 a1 < a2 < ... < am），那么：
- 这个序列可以从 b 中的任何一个完整的 [1,2,...,k] 子数组中选取（其中 k >= am）
- 有 n - am + 1 个这样的子数组（即 [1,2,...,am], [1,2,...,am+1], ..., [1,2,...,n]）

## 算法详解

### 步骤1：检查是否为严格递增序列

```cpp
int inc = 0;
FOR(i, 1, sbn) if (lovsub[i] > lovsub[i - 1]) inc++; else inc = 0;
```

这里使用了一个巧妙的技巧：
- `inc` 记录当前连续递增的长度
- 如果遇到非递增的情况，立即重置为 0
- 最终 `inc == sbn - 1` 表示整个序列都是严格递增的

### 步骤2：计算答案

```cpp
if (inc == sbn - 1) return n - lovsub.back() + 1;
return 1;
```

- **严格递增情况**：返回 `n - lovsub.back() + 1`
  - `lovsub.back()` 是序列的最大值
  - 可以从包含这个最大值的所有子数组中选取
- **非严格递增情况**：返回 1
  - 只有唯一的一种匹配方式

## 算法正确性

### 为什么严格递增序列有多种匹配方式？

考虑 fsb = [1, 2, 3]：
- 可以从子数组 [1,2,3] 中选取
- 可以从子数组 [1,2,3,4] 中选取
- 可以从子数组 [1,2,3,4,5] 中选取
- ...
- 总共有 n - 3 + 1 = n - 2 种方式

### 为什么非严格递增序列只有一种匹配方式？

如果序列不是严格递增的，比如 [1, 3, 2]：
- 这种模式在构造的数组 b 中只能以特定的方式出现
- 不能通过选择不同的子数组来获得相同的子序列

## 复杂度分析

- **时间复杂度**：O(m)，其中 m 是子序列的长度
- **空间复杂度**：O(1)，只使用了常数额外空间

## 关键观察

1. **构造规律**：理解数组 b 的构造方式是解题的关键
2. **递增性质**：严格递增的子序列具有特殊的匹配性质
3. **计数技巧**：通过最大值来确定可能的匹配位置数量

## 实现细节

- 使用 `inc` 变量巧妙地检测严格递增性
- 通过 `lovsub.back()` 获取序列的最大值
- 边界情况处理：非递增序列统一返回 1
