# Max Frequency

[力扣3347. 执行操作后元素的最高频率 II](https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-ii/description/)

**提示：** 如何高效计算每个目标值能够达到的最大频率？

这是一道经典的贪心+差分数组题。题目要求在有限次操作下，通过调整数组元素值（每个元素最多调整k），使某个值的出现频率最大化。

**核心思路：**

问题的关键在于：对于任意目标值x，我们需要快速计算有多少个数组元素可以通过操作变成x。

1. **贪心策略**：
   - 对于目标值x，优先选择已经等于x的元素（不需要操作）
   - 然后选择距离x最近的元素进行调整
   - 每个元素ai可以变成范围[ai-k, ai+k]内的任意值

2. **差分数组优化**：
   - 直接枚举所有可能的目标值会超时
   - 使用差分数组快速计算每个位置的"可达性"

**算法详解：**

**第一步：统计原始频率**
```cpp
umpii cnt;  // 统计每个值的原始出现次数
for (int x : a) {
    cnt[x]++;
}
```

**第二步：构建差分数组**
```cpp
map<int, int> diff;  // 差分数组
for (int x : a) {
    diff[x];           // 确保x在map中
    diff[x - k]++;     // 区间[x-k, x+k]的左端点+1
    diff[x + k + 1]--; // 区间[x-k, x+k]的右端点+1处-1
}
```

**关键理解：差分数组的含义**

对于数组元素ai，它可以变成范围[ai-k, ai+k]内的任意值。我们想知道：
- 对于任意目标值x，有多少个元素可以变成x？
- 这等价于：有多少个区间[ai-k, ai+k]包含点x？

差分数组的巧妙之处：
- `diff[x-k]++`：表示从位置x-k开始，可达元素数量+1
- `diff[x+k+1]--`：表示从位置x+k+1开始，可达元素数量-1
- 通过前缀和还原，`sumd`就是当前位置x的可达元素总数

**第三步：扫描线计算答案**
```cpp
int ans = 0, sumd = 0;
for (auto [x, c] : diff) {
    sumd += c;  // 前缀和：当前位置x的可达元素数量
    // cnt[x]: 已经等于x的元素数量（不需要操作）
    // op: 剩余操作次数
    // sumd: 总共可以变成x的元素数量
    ans = max(ans, min(cnt[x] + op, sumd));
}
```

**算法正确性分析：**

1. **贪心选择**：
   - 优先使用已经等于x的元素：`cnt[x]`
   - 剩余操作用于调整其他元素：最多`op`次
   - 总频率不能超过可达元素总数：`sumd`

2. **差分数组的正确性**：
   - 每个元素ai贡献一个区间[ai-k, ai+k]
   - 差分数组+前缀和正确计算了区间覆盖数量
   - 扫描所有关键点（区间端点）确保不遗漏最优解

**复杂度分析：**

- **时间复杂度**：O(n log n) - 主要是map的插入和遍历
- **空间复杂度**：O(n) - 存储cnt和diff

**关键观察：**

1. **离散化思想**：只需考虑关键点（原数组值和区间端点）
2. **差分优化**：将区间更新转化为点更新，O(1)时间处理每个区间
3. **贪心策略**：对于每个目标值，贪心地使用操作次数

