# The Meeting Place Cannot Be Changed

## 题目链接
[Codeforces 780B](https://codeforces.com/problemset/problem/780/B)

## 题目理解

有 n 个人，第 i 个人初始位置在 x[i]，最大速度为 v[i]。所有人要在某个时刻 t 聚集到同一个位置。求最小的聚集时间 t。

每个人在时间 t 内能到达的范围是 [x[i] - v[i] * t, x[i] + v[i] * t]。

## 核心观察

### 关键洞察
1. **区间交集问题**：所有人能够聚集的充要条件是所有人的可达区间有交集
2. **二分答案**：时间 t 具有单调性，如果时间 t 可行，那么所有大于 t 的时间也可行
3. **几何意义**：问题等价于找到最小的 t，使得所有区间 [x[i] - v[i] * t, x[i] + v[i] * t] 有非空交集

### 可行性判断
对于给定时间 t，判断是否可行：
- 计算每个人的可达区间：[x[i] - v[i] * t, x[i] + v[i] * t]
- 求所有区间的交集：[max(left_i), min(right_i)]
- 如果 max(left_i) ≤ min(right_i)，则时间 t 可行

## 算法思路

### 二分搜索 + 区间交集
1. **二分范围**：时间 t 的范围是 [0, 2×10^9]（根据题目约束估算）
2. **可行性检查**：对于中点时间 mid，检查所有人是否能聚集
3. **更新边界**：如果可行则缩小上界，否则增大下界

### 算法步骤
```cpp
bool possible(double t, const vll& x, const vll& v) {
    double lmx = -1e18;  // 所有左端点的最大值
    double rmx = 1e18;   // 所有右端点的最小值
    int n = x.size();
    For(i, n) {
        double left = x[i] - v[i] * t;
        double right = x[i] + v[i] * t;
        lmx = max(lmx, left);  // 更新交集的左边界
        rmx = min(rmx, right); // 更新交集的右边界
    }
    return lmx <= rmx;  // 交集非空
}

// 二分搜索
double lo = 0.0, hi = 2e9;
FOR(i, 0, 100) {  // 100次迭代保证精度
    double mid = (lo + hi) / 2;
    if (possible(mid, x, v)) {
        hi = mid;  // 可行，尝试更小的时间
    } else {
        lo = mid;  // 不可行，需要更大的时间
    }
}
```

## 算法正确性

### 单调性证明
- 如果时间 t 可行，那么时间 t' > t 也必然可行
- 因为更长的时间意味着每个人的可达范围更大
- 更大的可达范围意味着交集更容易存在

### 精度控制
- 使用 100 次二分迭代，精度约为 2×10^9 / 2^100 ≈ 10^-21
- 题目要求精度通常为 10^-6 到 10^-9，完全满足

### 边界处理
- 初始上界 2×10^9 足够大，覆盖所有可能的答案
- 初始下界 0 表示最理想情况（所有人已在同一位置）

## 复杂度分析

- **时间复杂度**：O(n log(max_answer / precision))
  - 二分搜索：O(log(2×10^9 / 10^-12)) ≈ O(100)
  - 每次可行性检查：O(n)
  - 总体：O(100n) = O(n)

- **空间复杂度**：O(n)
  - 存储位置和速度数组

## 关键观察

### 几何直观
1. **时空图**：在时间-位置坐标系中，每个人的可达区域是一个菱形
2. **交集条件**：所有菱形在某个时刻有公共区域
3. **最优时间**：使得交集刚好出现的最小时间

### 数学本质
1. **线性规划**：每个约束是 |position - x[i]| ≤ v[i] * t
2. **可行域**：所有约束的交集
3. **目标函数**：最小化时间 t
