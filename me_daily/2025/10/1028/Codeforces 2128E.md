# Codeforces 2128E - Decode

## 题目链接
[Codeforces 2128E](https://codeforces.com/problemset/problem/2128/E)

## 题目理解

给定一个长度为 n 的数组 a 和一个整数 k。需要找到一个长度至少为 k 的连续子数组，使得这个子数组中大于等于某个值 v 的元素个数不少于小于 v 的元素个数。

要求输出：
1. 满足条件的最大的 v 值
2. 对应的子数组的左右端点

## 核心观察

### 关键洞察
1. **二分答案**：对于值 v，可以将数组转换为 +1/-1 序列，问题转化为找最长的非负前缀和子数组
2. **前缀和技巧**：将 ≥v 的元素看作 +1，<v 的元素看作 -1，求前缀和
3. **滑动窗口**：在长度至少为 k 的窗口中，找到前缀和非负的子数组
4. **贪心策略**：为了最大化子数组和，选择最小的起始前缀和

### 问题转化
对于给定的 v：
- 如果 a[i] ≥ v，则贡献 +1
- 如果 a[i] < v，则贡献 -1
- 问题变成：找长度 ≥k 的子数组，使得其和 ≥0

## 算法思路

### 二分搜索 + 前缀和 + 贪心
1. **二分范围**：v 的取值范围是 [1, n]（数组元素的排名）
2. **可行性检查**：对于每个 v，检查是否存在满足条件的子数组
3. **前缀和优化**：使用前缀和快速计算子数组和
4. **贪心选择**：在滑动窗口中选择最小的起始前缀和

### 算法步骤
```cpp
auto check = [&](int vi) -> pii {
    vector<int> s(n + 1, 0);
    // 构建前缀和数组
    for (int i = 1; i <= n; i++) {
        int val = (a[i] >= vi ? 1 : -1);
        s[i] = s[i - 1] + val;
    }
    
    int pos = 0;  // 记录最小前缀和的位置
    for (int i = k; i <= n; i++) {
        // 更新最小前缀和位置
        if (s[i - k] < s[pos]) pos = i - k;
        // 检查当前子数组 [pos+1, i] 是否满足条件
        if (s[i] - s[pos] >= 0) {
            return {pos + 1, i};
        }
    }
    return {0, 0};  // 不存在满足条件的子数组
};

// 二分搜索最大的 v
int lo = 1, hi = n, ans = 0;
pii res = {0, 0};
while (lo <= hi) {
    int vi = lo + (hi - lo) / 2;
    auto lr = check(vi);
    if (lr.fi > 0) {
        ans = vi;
        res = lr;
        lo = vi + 1;  // 尝试更大的 v
    } else {
        hi = vi - 1;  // v 太大，减小范围
    }
}
```

## 算法正确性

### 单调性证明
- 如果值 v 可行，那么所有小于 v 的值也都可行
- 因为更小的 v 意味着更多的 +1，更容易满足非负条件
- 这保证了二分搜索的正确性

### 贪心策略正确性
- 对于固定的右端点 i，选择最小的左端点前缀和 s[pos]
- 这样可以最大化子数组和 s[i] - s[pos]
- 如果存在满足条件的子数组，这种策略一定能找到

### 滑动窗口优化
- 维护长度至少为 k 的窗口
- 在窗口滑动过程中，动态维护最小前缀和位置
- 时间复杂度从 O(n²) 优化到 O(n)

## 复杂度分析

- **时间复杂度**：O(n log n)
  - 二分搜索：O(log n)
  - 每次检查：O(n)
  - 总体：O(n log n)

- **空间复杂度**：O(n)
  - 前缀和数组：O(n)

## 关键观察

### 数学本质
1. **符号化**：将比较问题转化为符号序列问题
2. **前缀和**：利用前缀和快速计算区间和
3. **单调性**：利用答案的单调性进行二分搜索


