# Find X Sum

题目：给定数组 `nums`、窗口大小 `k` 和整数 `x`，对每个长度为 `k` 的子数组计算它的 `x-sum`。

`x-sum` 的定义：
- 统计子数组中每个元素的出现次数。
- 仅保留出现次数最多的前 `x` 个元素的所有出现；若出现次数相同，则数值更大的元素“更优先”。
- 结果为保留后的数组元素之和（等价于对被保留元素做 `出现次数 * 元素值` 再求和）。
- 若不同元素个数少于 `x`，则保留全部元素。

## 数据结构设计：L 与 R
- 使用两个有序集合（`SortedList`）来维护窗口中的元素，元素以二元组 `(freq, val)` 表示：
  - `L`：保存“最大的”`x` 个元素（按 `(freq, val)` 的比较结果）。
  - `R`：保存剩余的元素。
- `sum_l`：为 `L` 中所有元素的加权和，即 `sum(freq * val)`，正是子数组的 `x-sum`。

关键点：
- 二元组比较是**字典序**（Python 默认）：先比 `freq`，相等再比 `val`。
- 我们按“越大越应该进入 `L`”的规则维护：
  - 若某个 `(freq, val)` 比 `L` 中的最小值还大，就放入 `L`；否则放入 `R`。
  - 若 `L` 的数量不足 `x`，就从 `R` 中取最大的（`R[-1]`）搬到 `L`；若 `L` 超过 `x`，则把 `L` 中最小的（`L[0]`）搬回 `R`。

因此：当出现次数相同（`freq` 相同）时，`val` 更大的元组被视为“更大”，会优先进入 `L`。这就满足了题目中的并列时按数值大的优先的要求。

## 为何 `(2, 1)` 会在 `(2, 2)` 前面？
- `SortedList` 是**升序**排列，比较规则是 `(freq, val)` 的字典序。
- 频次都为 2 时，比较 `val`：`1 < 2`，所以 `(2, 1)` 比 `(2, 2)` 小，因而在升序集合中位置更靠前。
- 但当我们需要把“最大的”搬到 `L` 时，会从 `R` 的末尾取元素（`R[-1]`），也就是把 `(2, 2)` 这样的更大值优先搬入 `L`，从而实现并列时数值大的优先。

## 窗口维护流程（滑动窗口）
对数组从左到右滑动，每次处理新进入的元素 `in_`，并在窗口形成后计算答案：
- `remove(in_)`：先把 `in_` 以旧频次对应的元组从 `L/R` 中移除（若存在）。
- `cnt[in_] += 1`：更新频次。
- `add(in_)`：按规则把新元组加入 `L` 或 `R`。
- 当左端 `l = r + 1 - k` 满足 `l >= 0` 时，窗口有效：
  - 通过反复执行 `r2l()`（从 `R` 取最大到 `L`）和 `l2r()`（从 `L` 取最小到 `R`）
  - 保证 `len(L) == x`。
  - 此时 `sum_l` 即为该窗口的 `x-sum`。
- 移出左端元素 `out = nums[l]`：
  - `remove(out)` → `cnt[out] -= 1` → `add(out)`，保持集合与频次一致。

## 示例解释
示例一：`nums = [1,1,2,2,3,4,2,3], k = 6, x = 2`
- 窗口 `[1,1,2,2,3,4]`：频次 `1:2, 2:2, 3:1, 4:1`，并列按值大优先，取 `{2,1}`，`x-sum = 2*2 + 2*1 = 6`。
- 窗口 `[1,2,2,3,4,2]`：频次 `2:3, 1:1, 3:1, 4:1`，并列的三个里按值大优先取 `{4}` 补满，`x-sum = 3*2 + 1*4 = 10`。
- 窗口 `[2,2,3,4,2,3]`：频次 `2:3, 3:2, 4:1`，取 `{2,3}`，`x-sum = 3*2 + 2*3 = 12`。

示例二：`nums = [3,8,7,8,7,5], k = 2, x = 2`
- `k == x` 时，保留所有元素，`x-sum` 就是窗口和。

## 复杂度
- 每次对 `SortedList` 的插入/删除/访问为 `O(log m)`，`m` 为窗口内不同元素数，最坏 `m ≤ k`。
- 总体时间复杂度 `O(n log k)`，空间复杂度 `O(k)`（计数与集合）。

