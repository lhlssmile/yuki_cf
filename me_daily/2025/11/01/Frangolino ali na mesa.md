

# Frangolino ali na mesa - 详细解法分析

## 题目理解

这是一个概率期望问题。给定一个数组，我们需要计算经过随机操作后每个位置的期望值。

**核心操作**：每次随机选择一个元素，有1/2概率保持原位，1/2概率向左移动一位（如果已经在最左边则保持不变）。

## 算法核心思路

### 关键观察

1. **从右往左处理**：这样可以确保处理每个元素时，右边元素的贡献已经计算完毕
2. **期望值的递推性质**：每个位置的期望值可以通过递推关系计算
3. **概率分布**：每次操作都有1/2的概率影响当前位置

	总期望 = 所有可能“上菜事件”的概率 * 份数 之和。我们不用关心路径怎么连（移动后上菜、上菜后移动的交叉），直接拆解成**每个“到达事件”独立贡献**的部分。

- 一个“上菜事件”：某个命令 m 被执行为“上菜”（概率 1/2），且**当前位置是 i**，然后加 X_m 份到 i。
- 当前位置是 i 的概率，正好可以拆成：最近一次“到达 i”的概率 * 从那之后到 m 连续“上菜”（不移动）的概率（几何分布：(1/2)^{m-k-1}，k 是到达命令）。
- 所有这样的“最近到达”互斥（路径上每个段独立），所以直接对每个到达 k（X_k=i）加：Pr(到达k) * [后续上菜的期望份数]。
### 核心变量解释

```python
rev2 = (mod + 1) // 2  # 2的模逆元，用于计算除以2
cur = 0                # 当前累积的期望贡献
ans = [0] * (n + 1)    # 每个位置的最终期望值
```

## 算法步骤详解

### 1. 从右往左遍历

```python
for v in reversed(nums):
```

**为什么从右往左？**
- 右边元素的移动会影响左边位置的期望值
- 从右往左确保计算顺序正确

### 2. 更新当前位置的期望值

```python
ans[v] = (ans[v] + cur * rev2) % mod
```

**含义解释**：
- `cur`：从右边累积过来的期望贡献
- `cur * rev2`：由于每次有1/2概率向左移动，所以贡献要除以2
- 这部分贡献会加到位置v上

### 3. 更新累积期望值

```python
cur = (cur + v) * rev2 % mod
```

**递推关系**：
- `cur + v`：当前位置的值v加上之前累积的期望
- `* rev2`：每次操作有1/2概率向左移动，所以整体期望要除以2

### 4. 处理边界情况

```python
ans[1] = (ans[1] + cur) % mod
```

**最左边位置**：所有向左移动但无法继续移动的期望值都会累积到位置1

## 数学原理

### 递推关系推导

设S[i]表示从位置i开始的期望贡献：

```
S[i] = v[i]/2 + S[i+1]/2
```

**解释**：
- `v[i]/2`：当前值有1/2概率留在原位
- `S[i+1]/2`：有1/2概率向左移动，获得右边的期望贡献

**变形**：
```
S[i] = (v[i] + S[i+1]) / 2
```

这正是代码中`cur = (cur + v) * rev2`的数学表达！

## 具体例子验证

假设输入数组为`[3, 2, 4]`：

### 初始状态
```
rev2 = 500000004  # 2的模逆元
cur = 0
ans = [0, 0, 0, 0, 0]  # 索引1-4
```

### 步骤1：处理元素4（最右边）
```
v = 4
ans[4] += cur * rev2 = 0 * 500000004 = 0
cur = (cur + v) * rev2 = (0 + 4) * 500000004 = 2
```

### 步骤2：处理元素2
```
v = 2
ans[2] += cur * rev2 = 2 * 500000004 = 1
cur = (cur + v) * rev2 = (2 + 2) * 500000004 = 2
```

### 步骤3：处理元素3
```
v = 3
ans[3] += cur * rev2 = 2 * 500000004 = 1
cur = (cur + v) * rev2 = (2 + 3) * 500000004 = 2500000012 % MOD
```

### 步骤4：处理边界
```
ans[1] += cur = 2500000012
```

### 最终结果
```
ans[1] = 2500000012  # 位置1的期望值
ans[2] = 1           # 位置2的期望值  
ans[3] = 1           # 位置3的期望值
ans[4] = 0           # 位置4的期望值
```

## 算法优势

1. **时间复杂度**：O(n)，只需一次遍历
2. **空间复杂度**：O(n)，只需存储答案数组
3. **数值稳定性**：使用模逆元避免浮点数精度问题
4. **逻辑清晰**：直接对应数学递推关系

## 关键技巧

1. **模逆元的使用**：`rev2 = (mod + 1) // 2`巧妙计算2的逆元
2. **从右往左遍历**：保证依赖关系正确
3. **累积变量cur**：避免重复计算，提高效率
4. **边界处理**：最左位置特殊处理

## 完整代码实现

```python
def main(): 
    n, q = LII()
    nums = LII()
    mod = 10 ** 9 + 7
    rev2 = (mod + 1) // 2
    
    ans = [0] * (n + 1)
    
    cur = 0
    for v in reversed(nums):
        ans[v] = (ans[v] + cur * rev2) % mod
        cur = (cur + v) * rev2 % mod
    
    ans[1] = (ans[1] + cur) % mod
    
    print(*ans[1:], sep='\n')
```

