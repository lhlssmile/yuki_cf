
**创建日期：** 2025-11-20  
**标签：** #LeetCode #Greedy #Intervals #Notes  
**相关：** [[Interval Problems]] | [[Greedy Algorithm Thinking]]

---


## 🧠 我的初始想法
- **直觉：** 这像“区间覆盖”问题，但每个区间要“打”两次点。最小集合 → 最大化点重用。  
- **排序尝试：** 先按区间长度小到大排序（窄区间先处理），再按 start 升序。窄的先强制加2点，宽的可能复用。  
  - 为什么？最小区间长度至少2，必须加至少2点（end-1 和 end？）。  
  - 但问题：长度排序不一定捕捉重叠顺序，早结束的区间可能被忽略，导致后期多加点。  
- **选点：** 贪心地选右端点（靠近 end），因为右点更容易被后续区间（start 更大）包含。  
- **卡点：** 怎么跟踪“已覆盖”？全存点集太慢（n=3000，log n 查 O(n^2)）。需要聪明维护。  
- **调试感悟：** 调试后发现，**只维护最近两个最右点** 就够！因为排序后，早点不太会进后期区间。

**教训：** 初始排序规则重要，但先试“按 end 升序”——它像“截止时间调度”，确保早结束的先满足，不会回溯。

---

## 💡 关键洞察：怎么想出这个贪心？
### 1. **问题重构：** “每个区间至少2点” ≡ “用最少点覆盖所有区间，每次覆盖至少2次”。
   - 经典贪心：类似“区间选点覆盖”（选点最大化覆盖区间），但这里反过来（选点最小化，但多重覆盖）。  
   - **灵感来源：** 回想 [[Activity Selection]] 或 [[Jump Game]]——按“结束时间”排序，处理“紧迫”的先。  
     - 这里“紧迫” = end 小的区间，必须先确保它有2点，否则它“截止”了没法补。  
   - **为什么 end 排序？**  
     - 升序 end：从小到大处理，像流水线，早的 end ≤ 后 end，已加的右点很可能还在后区间里（start 可能重叠）。  
     - same end 时，按 start **降序**（start 大的先）：窄区间（start 接近 end）更“难满足”，先处理它，让宽的（start 小）更容易复用点。  
       - 例如：两个 end=5 的区间，[3,5]（窄）先处理，可能加 [4,5]；[1,5]（宽）直接复用。

### 2. **状态简化：为什么只维护两个点？**
   - **观察：** 处理当前区间时，所有之前区间已满足（排序保证）。  
     - 已加点中，只有**最右的两个**（last 和 second_last）可能进入当前区间（因为当前 start ≥ 之前一些 start，但 end 更大）。  
     - 更左的点？很可能 < 当前 start，不在里面。  
   - **检查覆盖：**  
     - 如果 start ≤ second_last：已有两个点在 [start, end] 内（second_last 和 last 都在）。跳过！  
     - 如果 start > last：零个点。必须加两个：贪心加 end-1 和 end（最右，利于未来重叠）。  
     - 中间：只有一个（last 在，但 second_last < start）。加一个：end，并移位（second_last = last）。  
   - **为什么 end/end-1？** 最大化未来复用——这些点在当前右端，后续区间 end ≥ 当前 end，更易包含它们。加左点（如 start）会“浪费”，因为左点难进未来区间。

### 3. **贪心正确性（简要证明思路）**
   - **最优性：** 假设有更小解，考虑第一个分歧点（算法加点，但最优没加）。由于排序，早区间已最优满足，后续点位置 ≤ 算法的（因为我们总选最右），矛盾。  
     - 形式：这个策略等价于“右端点优先 + 延迟添加”，在区间贪心中是最小化总点的。  
   - **调试验证：** 手推示例，检查每个区间真有≥2点，且总点≤其他方案。  
   - **边界：** 空/单区间（n=1，加2）；全重叠（加2够）；全分离（加2n）。


**时间：** O(n log n) 排序 + O(n) 扫。完美！


