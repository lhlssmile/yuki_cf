# Triple Removal

## 问题概述
**问题链接**： [https://codeforces.com/problemset/problem/2152/C](https://codeforces.com/problemset/problem/2152/C)

### 问题描述
- **输入**：多个测试用例（T ≤ 10^5，但 ∑n ≤ 2.5×10^5）。
  - 每个测试用例：N（数组长度，1 ≤ N ≤ 2.5×10^5），Q（查询数，1 ≤ Q ≤ 2.5×10^5）。
  - 数组 A[1..N]：每个元素为 0 或 1。
  - Q 个查询：每个查询给出一个区间 [L, R]（1 ≤ L ≤ R ≤ N）。
- **任务**：对于每个查询 [L, R]，计算**最小代价**来通过一系列操作使该子数组**为空**。
  - **操作**：从子数组中选择**三个相同元素**（全0或全1），删除它们。删除后，数组元素会**闭合**（下标重新编号，中间空隙消失）。
  - **代价**：每次操作的代价 = min(最左删除位置到L的距离, 最右删除位置到R的距离)。更精确地说，对于选择的三个位置 i < j < k（值相同），代价 = min(j - i, k - j)。
    - 官方解释：min(三个位置间的“跳跃”最小段）。
  - **目标**：使子数组为空，最小化**总代价**。如果不可能（无法删除到空），输出 -1。
- **约束**：数组元素只有 0/1，操作必须删除三个相同元素，所以总元素数必须能被 3 整除（分开 0 和 1 计数）。
- **时间复杂度要求**：O(N + Q) 整体（预处理 O(N)，查询 O(1)）。

### 关键洞见
- **不可能情况**：区间内 0 的数量 % 3 ≠ 0 或 1 的数量 % 3 ≠ 0 → 输出 -1。
- **可能情况**：假设 cnt0 = 0 的数量，cnt1 = 1 的数量，都能被 3 整除。
  - 需要进行 ops = (cnt0 / 3) + (cnt1 / 3) 次操作（每操作删 3 个相同元素）。
  - 每个操作的**最小代价**总是 1（因为可以选择相邻或近距离的三个相同元素，除非特殊情况）。
  - **特殊情况**：如果区间**完全交替**（即无两个相邻相同元素），则总代价 = ops + 1。
    - 为什么？在完全交替序列中（如 010101...），无法直接找三个相邻相同；第一个操作必须“跨越”更多，导致额外代价 1，后续操作才能降到 1。
- **总代价公式**：
  - 正常：ops
  - 完全交替：ops + 1

## 示例分析
### 第一测试用例
- 输入：
  ```
  2
  12 4
  0 0 1 1 0 1 0 1 0 1 1 0
  1 12
  2 7
  5 10
  6 11
  6 3
  0 0 0 1 1 1
  1 3
  4 6
  1 6
  ```
- 输出：
  ```
  4
  2
  3
  -1
  1
  1
  2
  ```

#### 第一查询 [1,12]
- 子数组：`[0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0]`
- cnt0 = 6, cnt1 = 6（两者 %3 ==0），ops = 2 + 2 = 4。
- **切换次数**：计算相邻不同：位置间不同有 8 次（总相邻对=11），8 < 11 → 非完全交替。
- 代价：4（纯 ops）。
- **操作序列示例**（官方解释）：
  1. 删三个1（位置3,4,6）：min(4-3=1,6-4=2)=1 → 数组：[0,0,0,0,1,0,1,1,0]
  2. 删三个0（位置1,2,3）：min(2-1=1,3-2=1)=1 → [0,1,0,1,1,0]
  3. 删三个1（位置2,4,5）：min(4-2=2,5-4=1)=1 → [0,0,0]
  4. 删三个0（位置1,2,3）：min(2-1=1,3-2=1)=1 → 空
  - 总：4。

#### 第四查询 [6,11]（-1 示例）
- 子数组：`[1,0,1,0,1,1]`（从原数组位置6-11）
- cnt0=2, cnt1=4 → 2%3≠0 → -1。

#### 第二测试用例查询 [1,6]
- 子数组：`[0,0,0,1,1,1]`
- cnt0=3, cnt1=3 → ops=1+1=2。
- 切换次数：1（位置3-4），总对=5 → 非交替。
- 代价：2。

## 解题思路
### 1. 可行性判断（O(1) 查询）
- 预处理**前缀和**：
  - `sum0[i]`：前 i 个位置的 0 数量。
  - `sum1[i]`：前 i 个位置的 1 数量。
- 查询 [L,R]：cnt0 = sum0[R] - sum0[L-1]，cnt1 = sum1[R] - sum1[L-1]。
- 如果 cnt0 % 3 ≠ 0 或 cnt1 % 3 ≠ 0 → -1。

### 2. 最小代价计算（O(1) 查询）
- ops = (cnt0 / 3) + (cnt1 / 3)。
- 检查是否**完全交替**：
  - 预处理**切换前缀和** `diffsum[i]`：前 i 个位置的**相邻不同**次数（d = (A[i] != A[i-1]) ? 1 : 0）。
  - 查询 [L,R]：switches = diffsum[R] - diffsum[L-1]（实际切换次数）。
  - num_pairs = R - L（相邻对数 = 长度 - 1）。
  - 如果 switches == num_pairs → 完全交替（每个相邻都不同），代价 = ops + 1。
  - 否则：代价 = ops。
- **为什么 +1？**
  - 完全交替序列（如 010101...）：长度必须 %3==0（因为 cnt0 ≈ cnt1）。
  - 第一个操作：无法找三个连续相同，必须选间隔大的（如 0在1,3,5：min(3-1=2,5-3=2)=2），但实际分析显示总多1。
  - 后续操作后，序列会产生连续相同，代价降回1。
  - Editorial 证明：总代价 = (总元素/3) + [完全交替 ? 1 : 0]。

### 3. 边界情况
- N=0 或空区间：但 L≤R，所以至少1元素；如果 cnt0+cnt1 <3 且 %3==0（0元素，但无效）。
- 全相同元素：switches=0 < num_pairs（除N=1），非交替，ops = N/3（代价全1）。
- 完全交替示例：`[0,1,0]`（N=3）：ops=1（删三个？等下，cnt0=2,cnt1=1 → %3≠0，无效）。有效如 `[0,1,0,1,0,1]`：cnt0=3,cnt1=3,ops=2,switches=5==5 → 代价=3。
- 注意：A[0] 哨兵设为 -1，确保 diffsum[1] 正确（A[1] != A[0] 总是切换）。

## 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

#define For(i, n) for (int i = 0; i < (n); ++i)
#define FOR(i, a, b) for (int i = (a); i < (b); ++i)

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t;
    cin >> t;
    For(_, t) {
        int n, q;
        cin >> n >> q;
        vector<int> a(n + 1);
        a[0] = -1;  // 哨兵，确保 diffsum[1] 正确
        For(i, n) {
            int idx = i + 1;
            cin >> a[idx];
        }
        vector<int> sum0(n + 1, 0);
        vector<int> sum1(n + 1, 0);
        vector<int> diffsum(n + 1, 0);
        For(i, n) {
            int idx = i + 1;
            sum0[idx] = sum0[idx - 1] + (a[idx] == 0);
            sum1[idx] = sum1[idx - 1] + (a[idx] == 1);
            int d = (a[idx] != a[idx - 1]);
            diffsum[idx] = diffsum[idx - 1] + d;
        }
        For(iq, q) {
            int l, r;
            cin >> l >> r;
            int z = sum0[r] - sum0[l - 1];
            int o = sum1[r] - sum1[l - 1];
            if (z % 3 != 0 || o % 3 != 0) {
                cout << -1 << '\n';
                continue;
            }
            int num_ops = z / 3 + o / 3;
            int switches = diffsum[r] - diffsum[l - 1];  // [l,r] 切换次数
            int num_pairs = r - l;  // 相邻对数
            int ans = num_ops;
            if (switches == num_pairs) {
                ans += 1;
            }
            cout << ans << '\n';
        }
    }
    return 0;
}
```
