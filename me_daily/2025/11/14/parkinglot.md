# Parking lot

问题：一条长度 `L = 2n - 2` 的停车位，车品牌有 4 种。统计“恰好出现一段长度为 `n` 的同品牌连续车”的填充方案数。

**关键观察**
- 因为 `L = 2n - 2 < 2n`，整条序列最多只能出现一段长度 ≥ `n` 的同色连续段（不可能有两段）。
- “恰好长度为 n”意味着这段的两端（若存在相邻格）不能被同色继续延长；也就是这段左右相邻位置必须都不是该颜色。

```
l = 2n - 2 ，必须有n个连续
1. 段在两端 只有一段相邻格
还剩 2n - 2 - (n + 1) = n - 3个位置 四种颜色随便选
2 * 4^(n - 3)! * 3 * 4

```

**分情况计数**
- 总可选起点数：`L - n + 1 = n - 1`。其中两端起点是 `s = 1` 与 `s = n - 1`，其余 `n - 3` 个起点在中间。
- 颜色选择：同色段的颜色有 `4` 种。

1) 段在两端（起点 `s` 为 1 或 `n-1`）
- 相邻约束：只有一侧相邻格存在，且必须“不等于该段颜色” → `3` 种选择。
- 其余位置数：`L - n - 1 = (2n - 2) - n - 1 = n - 3`，每个位置可任意 4 色 → `4^(n - 3)`。
- 对于“固定颜色 + 固定边缘起点”的贡献：`3 * 4^(n - 3)`。
- 两个边缘起点、再乘 4 种颜色：`4 * 2 * 3 * 4^(n - 3)`。

2) 段在中间（起点 `s` 在 2..`n-2`）
- 相邻约束：左右两侧相邻格都存在，且都必须“不等于该段颜色” → `3 * 3 = 9` 种选择。
- 其余位置数：`L - n - 2 = (2n - 2) - n - 2 = n - 4`，每个位置可任意 4 色 → `4^(n - 4)`。
- 对于“固定颜色”，所有中间起点的总贡献：`(n - 3) * 9 * 4^(n - 4)`。
- 乘上 4 种颜色：`4 * (n - 3) * 9 * 4^(n - 4)`。

**汇总与化简**
- 总数：
  - `Answer(n) = 4 * [ 2 * 3 * 4^(n - 3) + (n - 3) * 9 * 4^(n - 4) ]`
- 把第二项中的 `4` 合并到幂：`36 * 4^(n - 4) = 9 * 4^(n - 3)`，于是：
  - `Answer(n) = (9n - 3) * 4^(n - 3)`（适用于 `n ≥ 3`）。

**每个因子的含义（回答你的疑惑）**
- `2`：两端的两个起点（段贴左边界或右边界）。
- `3`：相邻格必须不是段的颜色，故有 3 种选择。
- `4^(n - 3)`：边缘情形下，除了这段和唯一一个相邻格外，剩下 `n - 3` 个位置完全自由，每个 4 种颜色，乘法原则得此幂。
- 中间情形的 `9 * 4^(n - 4)` 同理：两侧相邻各 3 种，乘为 9；其余 `n - 4` 个位置自由，每个 4 种。
- “剩下的 `n - 2` 个位置只能是 3 种颜色吗？”不是的。只有紧贴这段的相邻格受“不可同色”约束是 3 种；更远的格子是 4 种随意。
- 为什么不会出现第二段长度 `n` 的同色段？因为移除这段后，剩余长度是 `n - 2`（或 `n - 3`/`n - 4`），不足以形成另一段长度 `n` 的连续段，因此不需额外排除。

**小例自检**
- `n = 3, L = 4`：
  - 边缘起点两个；边缘贡献（固定颜色）每个为 `3 * 4^(0) = 3`，两边合 `6`；乘 4 色 → `24`。
  - 公式 `Answer(3) = (27 - 3) * 4^0 = 24`。
- `n = 4, L = 6`：
  - 边缘：每边 `3 * 4^(1) = 12`（固定颜色），两边合 `24`；乘 4 色 → `96`。
  - 中间：`(n-3)=1` 个起点，贡献 `9 * 4^0 = 9`（固定颜色），乘 4 色 → `36`。
  - 总计 `96 + 36 = 132`；公式 `Answer(4) = (36 - 3) * 4^1 = 132`。

**代码实现**

Python（支持区间打印）：
```python
def count_ways(n: int) -> int:
    return (9 * n - 3) * pow(4, n - 3)

for n in range(3, 30 + 1):
    print(n, count_ways(n))
```

C++（可用你学的快速幂来算 `4^(n-3)`）：
```cpp
long long binPowNoRecursion(long long a, long long b) {
    long long res = 1;
    while (b > 0) {
        if (b & 1) res *= a;
        a *= a;
        b >>= 1;
    }
    return res;
}

long long answer(long long n) {
    return (9 * n - 3) * binPowNoRecursion(4, n - 3);
}
```

**一句话总结**
- 先选颜色与起点，再满足“相邻不可同色”，其余格子自由，乘法原则即可。最终闭式：`(9n - 3) * 4^(n - 3)`。