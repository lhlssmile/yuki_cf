# Buses — 坐标压缩与线段树笔记

## 题目模型与关键结论
- 公交区间 `[s, t]` 对任一乘客的最优使用时间是常数：`(t - s)/x + (ℓ - t)/y`。
- 对某乘客位置 `p` 的答案是两者取最小：
  - 纯步行：`(ℓ - p)/y`
  - 所有覆盖 `p` 的公交区间的常数值的最小值。
- 因为只需要在每个乘客的 `p` 上查询“覆盖该点的区间最小值”，数据结构选择“区间取最小 + 点查询”更高效。

## 坐标压缩（coords）
- 目的：把可能很大的坐标（最多到 `1e9`）映射到紧凑的索引区间 `[0..U-1]`，以便建树和做区间更新。
- 具体做法：
  - 收集所有 `s_i, t_i, p_i` 到一个数组 `coords`。
  - 排序去重后得到有序坐标表 `coords`。
  - 通过二分查找把任意值 `v` 映射到其索引 `id(v)`。
- 注意：我们只在乘客的点位上做查询，所以只需保证每个 `p_i` 在压缩表中。公交的 `s_i, t_i` 作为区间端点也必须在表中用于区间更新。

### 样例的坐标压缩
- 输入：
  - `ℓ=10, x=4, y=1`
  - 公交：`[0,5], [2,4], [7,9]`
  - 乘客：`p=3, 8, 5`
- 压缩后的有序坐标：`coords = [0, 2, 3, 4, 5, 7, 8, 9]`
- 映射：
  - `0→0, 2→1, 3→2, 4→3, 5→4, 7→5, 8→6, 9→7`
- 公交区间的索引区间：
  - `[0,5] → [0,4]`
  - `[2,4] → [1,3]`
  - `[7,9] → [5,7]`

## 区间常数值计算
- 对每个公交区间 `[s, t]`，计算常数：`val = (t - s)/x + (ℓ - t)/y`。
- 样例：
  - `[0,5] → val = 6.25`
  - `[2,4] → val = 6.5`
  - `[7,9] → val = 1.5`

## 线段树（区间取最小 + 点查询）
- 节点维护一个“标签”`tag[u]`，表示覆盖该节点整个区间的所有区间更新的最小值；初始为 `+∞`。
- 区间更新 `[L..R]`：在树上递归，遇到“完全覆盖”的节点时，做 `tag[u] = min(tag[u], val)`，不下传。
- 点查询 `idx`：从根到叶，沿途把所有经过的节点标签取最小（累积 `acc = min(acc, tag[u])`），到叶即得到覆盖该点的所有区间的最小值。
- 这种结构适合“只做点查询”的场景，避免了复杂的懒标记下传。

### 用样例画出树（`U=8`，索引 `[0..7]`）

```
                          [0..7]: +∞
                 /-------------------------\
            [0..3]: +∞                 [4..7]: +∞
           /---------\               /-----------\
       [0..1]: 6.25  [2..3]: 6.25   [4..5]: +∞    [6..7]: 1.5
       /-----\       /-----\        /-----\       /-----\
   [0..0]:6.25 [1..1]:6.25 [2..2]:6.25 [3..3]:6.25 [4..4]:6.25 [5..5]:+∞ [6..6]:+∞ [7..7]:1.5
```

- 解释：
  - 区间 `[0,4]`（公交 `[0,5]`）完全覆盖了节点 `[0..1]`、`[2..3]`、`[4..4]`，故这些节点的 `tag` 被赋为 `6.25`。
  - 区间 `[1,3]`（公交 `[2,4]`）会尝试更新 `[0..1]` 与 `[2..3]` 的子树，但其值 `6.5` 大于已有 `6.25`，因此最小值维持 `6.25`。
  - 区间 `[5,7]`（公交 `[7,9]`）完全覆盖了节点 `[6..7]` 与其祖先 `路径右半部分`中的某些节点（如 `[5..7]`），其中展示的是“在完全覆盖的节点处写入 `1.5`”。
  - 根与某些中间节点未被任何单个区间完全覆盖，`tag` 保持 `+∞`，但查询时会沿途取到子树里的有效值。

### 点查询示例（乘客）
- `p=3 → id=2`：查询路径 `[0..7]→[0..3]→[2..3]→[2..2]`，沿途最小标签为 `min(+∞, +∞, 6.25, +∞) = 6.25`；与步行 `7` 取最小，答案 `6.25`。
- `p=8 → id=6`：查询路径 `[0..7]→[4..7]→[6..7]→[6..6]`，沿途最小标签为 `min(+∞, +∞, 1.5, +∞) = 1.5`；与步行 `2` 取最小，答案 `1.5`。
- `p=5 → id=4`：查询路径 `[0..7]→[4..7]→[4..5]→[4..4]`，沿途最小标签为 `min(+∞, +∞, +∞, 6.25) = 6.25`；与步行 `5` 取最小，答案 `5`。

## 与代码的对应关系
- 坐标压缩与映射：`hana/me_daily/2025/11/24/Buses/b.cpp:39-46`
- 线段树的区间更新与点查询：`hana/me_daily/2025/11/24/Buses/b.cpp:47-54`
- 把公交常数值更新到 `[s_id, t_id]`：`hana/me_daily/2025/11/24/Buses/b.cpp:55`
- 每位乘客的最终答案（步行 vs 区间最小）输出：`hana/me_daily/2025/11/24/Buses/b.cpp:56-58`

## 小结与注意事项
- 只需构建“区间取最小 + 点查询”的树，因为我们只在 `p_i` 上查询。
- 坐标压缩必须包含所有区间端点与所有查询点，保证覆盖关系与查询正确。
- 浮点误差控制：使用 `double` 输出时设定足够精度（例如 10 位小数），满足题目 `1e-6` 的误差要求。