# Reverse XOR

## 问题描述

给定正整数 $n$，判断是否存在正整数 $x$ 使得 $x \oplus f(x) = n$，其中 $f(x)$ 是将 $x$ 的二进制表示反转后去除前导零得到的整数。

## 核心洞察

**关键观察**: $x \oplus f(x)$ 的二进制表示必然是回文数！

### 数学证明

设 $x$ 的二进制表示为 $b_k b_{k-1} \ldots b_1 b_0$，则 $f(x)$ 的二进制表示为 $b_0 b_1 \ldots b_{k-1} b_k$。

对于 $x \oplus f(x)$ 的第 $i$ 位：
- 如果 $x$ 和 $f(x)$ 的长度相同，第 $i$ 位 = $b_i \oplus b_{k-i}$
- 第 $k-i$ 位 = $b_{k-i} \oplus b_i = b_i \oplus b_{k-i}$

因此 $x \oplus f(x)$ 的二进制表示关于中心对称，即为回文数。

## 算法思路

问题转化为：**判断给定的 $n$ 是否可以表示为某个回文二进制数**

### 具体步骤

1. **枚举位长度**: 从 1 到 63 枚举可能的二进制位长度 $L$
2. **补齐位数**: 将 $n$ 的二进制表示用前导零补齐到长度 $L$
3. **检查回文**: 验证补齐后的字符串是否为回文
4. **奇数长度特殊处理**: 如果 $L$ 为奇数，中间位必须为 0
   - 原因：中间位对应 $b_i \oplus b_i = 0$

### 示例分析

以 $n = 6$ 为例：
- $n = 6$ 的二进制：`110`
- 尝试长度 4：补齐为 `0110`
- 检查回文：`0110` ≠ `0110` 的反转 `0110` ✓
- 长度 4 为偶数，无需检查中间位
- 结果：YES

对应的 $x = 11$ (二进制 `1011`)，$f(11) = 13$ (二进制 `1101`)
验证：$11 \oplus 13 = 1011 \oplus 1101 = 0110 = 6$ ✓

## 复杂度分析

- **时间复杂度**: $O(\log^2 n)$
  - 外层循环：$O(\log n)$ 种长度
  - 内层回文检查：$O(\log n)$
- **空间复杂度**: $O(\log n)$ 存储二进制字符串

## 代码实现要点

### Python版本
```python
t = int(input())
for _ in range(t):
    n = f"{int(input()):b}"  # 转二进制字符串
    ans = "NO"
    for i in range(1, 64):
        if len(n) <= i:
            w = n.zfill(i)  # 补齐前导零
            B = w == w[::-1]  # 检查回文
            if i % 2 == 1:
                B = B and w[i // 2] == '0'  # 奇数长度中间位检查
            if B:
                ans = "YES"
    print(ans)
```

