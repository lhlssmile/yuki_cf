# Number of Substrings — 1 显著计数（枚举零块法）

题意
- 给二进制串 `s`，统计满足“子串中 `1` 的个数 `≥ (0 的个数)^2`”的子串数。

实现思路（变量映射）
- `a`: 所有 `0` 的下标列表，末尾追加 `n`，即 `a = [p0, p1, ..., p_{M-1}, n]`。
- `cnt_pass0`: 当前左端点 `left` 之前出现的 `0` 的个数；于是 `a[cnt_pass0]` 是“左端点之后的第一个 0 的位置”。
- 枚举子串的零数：用 `k` 指向“子串中最后一个 0 的位置”在 `a` 中的下标，
  - 则子串的零数 `cnt0 = k - cnt_pass0 + 1`。
  - 为保持 `cnt0` 不变，右端点 `end` 必须落在 `[a[k], a[k+1]-1]`；这样的右端点数量是 `a[k+1] - a[k]`。
- 子串的最小 `1` 数（当右端点取到 `a[k]`）为：
  - `cnt1_min = (a[k] - left + 1) - cnt0`（子串长度减去零数）。
- 若 `cnt1_min ≥ cnt0^2`，则该区间里的所有右端点都合法，贡献 `a[k+1] - a[k]`。
- 否则需要补 `need = cnt0^2 - cnt1_min` 个 `1` 才能合法；右端点向右移动每一步会多 1 个 `1`，所以贡献是：
  - `max(a[k+1] - a[k] - need, 0)`。
- 代码对应：
  - 满足时：`ans += a[k + 1] - a[k]`
  - 不满足时：`ans += max(a[k + 1] - a[k] - (cnt0 * cnt0 - cnt1), 0)`。

为什么在 `a` 末尾追加 `n`
- 这让最后一段“尾部的连续 `1`”也被统一视为 `[a[M-1], a[M])` 的区间，避免对“最后一个 0 之后全是 `1`”的情况写特判。

边界剪枝 `if cnt0*cnt0 > tot1: break`
- `tot1` 是整个串的 `1` 总数。如果 `cnt0^2` 已经大于这个上限，任何子串都无法满足（子串的 `1` 个数不可能超过整串），且随着 `k` 增加，`cnt0` 单调增，故可直接 `break`。

当前的调试栈
- 栈：`s='101101'`, `n=6`, `a=[1,4,6]`, `left=0`, `x='1'`, `cnt_pass0=0`, `k=1`。
- 计算：
  - `cnt0 = k - cnt_pass0 + 1 = 2`（`0` 在位置 1 与 4）。
  - `cnt1 = a[k] - left + 1 - cnt0 = 4 - 0 + 1 - 2 = 3`，这个 `cnt1` 已经包含了当前字符 `x='1'`（因为它是用子串长度减零数算出来的）。
  - 需要补的 `1` 数：`need = cnt0^2 - cnt1 = 4 - 3 = 1`。
  - 保持 `cnt0` 不变的右端点区间长度：`a[k+1] - a[k] = 6 - 4 = 2`。这两个右端点是 `end=4` 与 `end=5`。
  - 合法的右端点个数：`max(2 - 1, 0) = 1`，对应将右端点取到 `5`（子串 `s[0..5]='101101'`，此时 `1` 的个数变成 `4`，满足 `4 ≥ 2^2`）。
- 结论：在这一步里，`ans` 的新增是 `1`，且当前的 `x='1'` 已计入 `cnt1`。


小结
- 关键：固定零块后，把“合法右端点的个数”转化为简单的线性扣除（`区间长度 - 需要补的 1 个数`）。