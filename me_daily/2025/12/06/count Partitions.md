

# 数组分割计数问题 —— 思路与笔记

## 题目简述

给定整数数组 `nums` 和整数 `k`，将数组划分为一个或多个连续子段，使得每段的最大值与最小值之差不超过 `k`。求所有合法划分方法数（对 1e9+7 取模）。

---

## 一、问题建模

定义状态：

> `dp[i]` 表示前 `i` 个元素 (`nums[0..i-1]`) 的合法分割总数

初始：

```
dp[0] = 1   // 空数组有 1 种划分方式（不选即一种）
```

转移：

以 `r` 为段结尾，若某段起始为 `j` 且合法，则：

```
dp[r] += dp[j]
```

即：

```
dp[r] = ∑ dp[j]  for all j in valid range
```

因此，关键点是高效地确定合法区间 `[l..r-1]` 上的所有 j。

---

## 二、合法区间的确定

对于每个右端点 `r`，我们向左收缩左端点 `l`：

保持区间 `nums[l..r]` 满足：

```
max(nums[l..r]) - min(nums[l..r]) <= k
```

随着 `r` 增大，`l` 单调不减，因此可使用双指针窗口。

---

## 三、区间最大最小的 **O(1) 动态维护**

使用两个双端队列（deque）：

|队列|性质|队头含义|
|---|---|---|
|maxq|单调递增下标对应值单调递减|当前窗口最大值位置|
|minq|单调递减下标对应值单调递增|当前窗口最小值位置|

右扩窗口：加入 `r` 时维护单调性  
左收缩窗口：若队头下标 == l 则移除（说明该值已移出窗口）

总复杂度保证为 O(n)，因为每个元素最多入队/出队一次。

---

## 四、DP + 前缀和加速求区间和

假设以 r 为右端点时合法起点区间为 `[l..r]`（包含 r 本身对应 dp[r] 为 dp[r+1]）：

```
dp[r+1] = dp[l] + dp[l+1] + ... + dp[r]
```

定义前缀和：

```
prefix[i] = dp[0] + dp[1] + ... + dp[i-1]
```

注意：

- prefix 的第 i 项累加到 dp[i-1]
    
- 因此区间 dp[l..r] 的和为：
    

```
prefix[r+1] - prefix[l]
```

于是：

```
dp[r+1] = prefix[r+1] - prefix[l]
```

保存前缀和按模处理。

---

## 五、为什么 `dp[0] = 1`？

数学含义：

> 空数组有 1 种有效划分方式：不划分。

这个值作为所有转移的基础，使得当从头开始一个合法区间时 dp 能正常累计。

例如：  
若 `nums[0..r]` 整段合法，则：

```
dp[r+1] 需要包含 dp[0] 对应的方式
```

若 dp[0]=0，则所有状态都无法转移。

dp[0] = 1 是 DP 的单位元。

---

## 六、时间与空间复杂度分析

|项|实现方式|复杂度|
|---|---|---|
|维护窗口合法|双指针 + 单调双端队列|O(n)|
|DP 转移|前缀和求区间和|O(1) 每次，总计 O(n)|
|总时间复杂度|—|**O(n)**|
|空间复杂度|dp + prefix + deque|**O(n)**|

满足 n ≤ 5×10⁴ 的要求。

---

## 七、代码片段（核心逻辑）

```cpp
dp[0] = prefix[0] = 1;

dp[r+1] = (prefix[r+1] - prefix[l] + mod) % mod;
prefix[r+1] = (prefix[r] + dp[r+1]) % mod;
```

---

## 八、总结

1. 问题是典型的区间 DP 叠加计数问题
    
2. 难点在于如何快速确定合法区间
    
3. 双指针 + 单调队列高效解决最大最小维护
    
4. 前缀和优化区间 DP 转移
    
5. 整体最优解复杂度 O(n)
    