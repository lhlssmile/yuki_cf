# Perfect Multiples 题解笔记

- 问题重述
  - 给定 `n, k` 与数组 `a`（每个 `a_i` 在 `[1..k]`）。
  - 构造集合 `B` 满足：
    - 覆盖性：对每个 `a_i`，存在 `b ∈ B` 使 `b | a_i`；
    - 完整性：对每个 `b ∈ B`，其所有正倍数 `b,2b,...,⌊k/b⌋·b` 都必须在 `a` 中出现至少一次。
  - 目标是最小化 `|B|`，不可行则输出 `-1`。

- 关键观察
  - 若取 `b ∈ B`，完整性要求的倍数集合包含 `b` 自身，因此 `b` 必须在 `a` 出现。故 `B ⊆ set(a)`。
  - 定义候选 `Good`：`v ∈ set(a)` 且其所有倍数 `v,2v,...,⌊k/v⌋·v` 都在 `set(a)` 中。只有 `Good` 元素可以进入 `B`。
  - 覆盖性与最小化：对每个 `a_i`，选择其“最小的 `Good` 因子”，收集这些因子并去重，即得到一个满足条件且规模最小的 `B`。若某个 `a_i` 不存在 `Good` 因子，则不可行。

- 为什么“最小 Good 因子”最优
  - 对同一个 `a_i`，若存在多个 `Good` 因子 `{g1, g2, ...}`，令 `g_min` 为最小者。
  - 任何更大的 `g'` 都是某个更小因子的倍数，其倍数集合（完整性要求）不会比更小因子覆盖更多的 `a` 值；用更小的因子既满足覆盖，又不会增加集合大小。

- 算法
  - 构造 `st = set(a)`。
  - 求 `Good`：对每个 `v ∈ st`，枚举 `t=1..⌊k/v⌋`，若 `v*t ∉ st` 则 `v` 非候选；否则是 `Good`。
  - 用所有 `Good v` 反向标记其倍数的“最小 Good 因子”：对 `m = v*t`，若 `m ∈ st`，则 `min_good_div[m] = min(min_good_div[m], v)`。
  - 对每个 `a_i`：若存在映射 `min_good_div[a_i]`，把该值加入答案集合；否则不可行。
  - 输出：不可行 `-1`；否则输出集合大小与升序的元素列表。

- 复杂度
  - `Good` 检查对每个 `v ∈ st`最多枚举 `⌊k/v⌋` 个倍数（遇缺即提前终止）。
  - 标记最小因子也只对实际存在的倍数执行更新。
  - 总体在题目约束下可行（当 `a` 稀疏时快速退出，当 `a` 致密时 `n` 总和受限）。

