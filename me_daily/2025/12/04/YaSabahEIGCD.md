# Ya Sabah El GCD 题解笔记

**怎么想**
- 目标是让 `gcd(a[1],...,a[n])` 变成 1。设初始 `G = gcd(a[1],...,a[n])`。
- 若 `G == 1`，不需要任何操作，答案为 0（对应 `a.py:40`）。
- 若 `G > 1`，设其质因子集合为 `P = {p1, p2, ..., pk}`。要把整体 gcd 降到 1，必须让每个质因子 `p ∈ P` 至少在一个位置消失：只要存在某个索引 `i` 使得“新 `a[i]` 不再含有 `p`”，那么 `p` 就不再是所有元素的公因子，从而从整体 gcd 中被剔除。
- 对某个索引 `i` 执行操作后，`a[i] := gcd(a[i], b[i])`。若 `b[i]` 不含质因子 `p`，则 `gcd(a[i], b[i])` 中一定不含 `p`，因此该次操作能“打掉”质因子 `p`。若 `b[i]` 含有 `p`，则无法打掉 `p`。
- 因此，问题被化简为：用若干索引 `i` 的操作，覆盖掉集合 `P` 中的所有质因子；每个索引 `i` 的“可覆盖集合”就是所有 `p ∈ P` 中满足 `b[i] % p != 0` 的那些质因子；代价是 `i^2 + i`。
- 这是一个“最小代价覆盖固定小集合”的问题；因为 `G` 的不同质因子数 `k` 很小（`≤` 质因子个数上限），可以用子集 DP 在 `O(n · 2^k)` 内做出来。

**数据结构与复杂度**
- 分解 `G` 的不同质因子列表：`primes = get_primes(G)`（对应 `a.py:22–35`）。
- 为每个位置 `i` 构造一个 `mask_i`，第 `j` 位为 1 当且仅当 `b[i]` 不含 `primes[j]`（对应 `a.py:51–57`）。这就是“`i` 能一次性打掉的质因子集合”。
- 子集 DP：`dp[mask] = 覆盖到质因子子集 mask 的最小总代价`（对应 `a.py:59–76`）。
  - 初始 `dp[0] = 0`。
  - 枚举 `i=1..n`，其代价 `cost = i*i + i`（对应 `a.py:64`），对所有 `prev` 递推：`newm = prev | mask_i`，更新 `dp[newm] = min(dp[newm], dp[prev] + cost)`。
  - 目标子集 `full = (1<<k) - 1`。答案是 `dp[full]`，若不可达则输出 `-1`。
- 复杂度：分解质因子 `O(√G)`，构造掩码 `O(n · k)`，DP `O(n · 2^k)`。当 `n ≤ 5000`、`k` 很小（通常 `≤ 10`）时，时间与空间都足够。

**一步步示例**
- 输入：`n=2`，`a=[6, 10]`，`b=[3, 7]`。
- 初始 `G = gcd(6,10) = 2`，质因子集合 `P = {2}`，因此 `k=1`。
- 构造每个位置的可覆盖集合：
  - `i=1`：`b[1]=3`，`3 % 2 != 0`，因此能打掉质因子 `2`，`mask_1 = 1`；代价 `cost_1 = 1^2 + 1 = 2`。
  - `i=2`：`b[2]=7`，`7 % 2 != 0`，因此也能打掉质因子 `2`，`mask_2 = 1`；代价 `cost_2 = 2^2 + 2 = 6`。
- 子集 DP：
  - 初始：`dp[0]=0`，`dp[1]=INF`。
  - 用 `i=1` 更新：`newm = 0 | 1 = 1`，`dp[1] = min(INF, dp[0]+2) = 2`。
  - 用 `i=2` 更新：`newm = 0 | 1 = 1`，`dp[1] = min(2, dp[0]+6) = 2`。
  - 目标 `full=1`，答案 `dp[1]=2`。
- 验证：在索引 1 执行一次操作，`a[1] := gcd(6,3) = 3`，新数组是 `a'=[3,10]`，其整体 `gcd(3,10)=1`，总代价 `2`，正确且更优于选索引 2（代价 6）。


**易错点与校验**
- 只需考虑 `G` 的质因子，而不是所有 `a[i]` 或 `b[i]` 的质因子；因为只有公因子会留在整体 gcd 里。
- 一个位置 `i` 的一次操作可以同时打掉多个质因子（那些 `b[i]` 不含的质因子），这就是用掩码合并的原因。
- 不可达判定：若某个 `p ∈ P` 对所有 `i` 都满足 `b[i] % p == 0`，则无论如何也打不掉该 `p`，最终答案必须是 `-1`；在 DP 里会体现为 `dp[full]` 仍为 `INF`。
