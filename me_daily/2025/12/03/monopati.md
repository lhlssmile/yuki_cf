# Monopati 题解笔记

**怎么想**
- 把“右/下路径”在 2×n 网格的形状先固定：路径从 `(1,1)` 向右走到某一列 `c`，然后下落到第二行，再继续向右到 `(2,n)`。每条合法路径都由这个“下落列” `c` 唯一决定。
- 对固定的 `c`，路径会经过两段：第一行的列 `1..c`，第二行的列 `c..n`。为了让二值网格 `f(l,r)` 在这条路径上全为 `1`，只需让区间 `[l,r]` 覆盖这两段上的所有值。
- 用两段上的值集合的最小与最大来刻画覆盖条件：
  - `L(c) = min( top[1..c], bottom[c..n] )`
  - `R(c) = max( top[1..c], bottom[c..n] )`
  - 连续区间 `[l,r]` 覆盖这条路径 ⇔ `l ≤ L(c)` 且 `r ≥ R(c)`。
- 问题转化为计数“存在某个 `c` 使 `[l,r] ⊇ [L(c), R(c)]` 的所有 `(l,r)`”。固定 `l` 时，只要有某个 `c` 满足 `L(c) ≥ l`，让 `r ≥ min_{L(c)≥l} R(c)` 即可。

**数据结构与复杂度**
- 只需要最值信息，使用一维数组做前缀/后缀即可，避免构造整个二值网格或枚举所有 `(l,r)`。
- 前缀最值（第一行）：`pmn1[c] = min(top[1..c])`，`pmx1[c] = max(top[1..c])`
- 后缀最值（第二行）：`smn2[c] = min(bottom[c..n])`，`smx2[c] = max(bottom[c..n])`
- 把每个 `c` 的区间 `[L(c), R(c)]` 汇总到数组 `exactR[L] = 该 L 对应的最小 R`（大小约 `2n`）。
- 再做一次从右到左的“前缀最小值”：`bestR[l] = min( exactR[l], bestR[l+1] )`，得到所有 `l` 的最小可行 `r`。
- 最后答案为 `sum_{l=1..2n} max(0, 2n - bestR[l] + 1)`。
- 时间复杂度 `O(n + 2n)`，空间复杂度 `O(n + 2n)`；不依赖于枚举 `(l,r)`，不会 TLE 或 MLE。

**例子走一遍**
- 输入：`n=2`，第一行 `a1=[1,3]`，第二行 `a2=[3,1]`。
- 前缀/后缀：
  - `pmn1 = [1, 1]`，`pmx1 = [1, 3]`
  - `smn2 = [1, 1]`，`smx2 = [3, 1]`
- 每个下落列的区间：
  - `c=1`（在第 1 列下落）：`L(1) = min(1,1)=1`，`R(1) = max(1,3)=3` → `[1,3]`
  - `c=2`（在第 2 列下落）：`L(2) = min(1,1)=1`，`R(2) = max(3,1)=3` → `[1,3]`
- 汇总到 `exactR`：`exactR[1]=3`，其他下标为无穷大。
- 右到左前缀最小：`bestR[4]=∞, bestR[3]=∞, bestR[2]=∞, bestR[1]=3`。
- 累加答案：只有 `l=1` 有效，贡献 `2n - bestR[1] + 1 = 4 - 3 + 1 = 2`，对应区间 `(1,3)` 与 `(1,4)`。

**实现提示**
- 遍历一次第一行构造前缀最小/最大，遍历一次第二行构造后缀最小/最大。
- 遍历 `c=1..n` 计算 `(L(c), R(c))` 并更新 `exactR[L]` 的最小值。
- 从 `v=2n` 到 `1` 扫描求 `bestR[v] = min(exactR[v], bestR[v+1])`。
- 对每个 `l` 累加 `max(0, 2n - bestR[l] + 1)`。

**易错点**
- 把路径当成“必须每列都取两行”是错误的；在 2×n 下路径只在一个列 `c` 下落，其它都在单行。
- 不需要构造二值网格 `b`，也不需要枚举 `(l,r)`；只看每条路径的最小/最大值即可。
- `bestR[l]` 是“所有 `L(c) ≥ l` 的最小 `R(c)`”；注意用右到左的前缀最小值实现这个“`L ≥ l`”的条件。
