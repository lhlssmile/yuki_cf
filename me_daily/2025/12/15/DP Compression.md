
# 压缩 DP（连续段计数）速记笔记

> 适用场景：**连续区间 + 局部条件成立 + 统计子数组/子区间数量**  
> 核心思想：**不存 DP 数组，只维护一个 `cur`**

---

## 一、你已经掌握的核心模型

我们关心的不是「整个区间」，而是：

> **以当前位置 i 结尾，满足条件的连续段有多长？**

定义：

- `cur`：当前连续段长度（或能贡献的子数组数量）
    
- `ans`：累计答案
    

**通用骨架：**

```text
如果 当前条件成立:
    cur += 1
否则:
    cur = 基础值
ans += cur
```

这是 **DP 压缩**：

- 原本的 `dp[i]`
    
- 被压缩成一个变量 `cur`
    

---

## 二、最经典的三类题型


#### 例：平滑下降阶段

条件：

```text
prices[i] == prices[i-1] - 1
```

代码骨架：

```go
cur := 0
for i := 0; i < n; i++ {
    if i > 0 && prices[i] == prices[i-1]-1 {
        cur++
    } else {
        cur = 1
    }
    ans += cur
}
```

**理解要点：**

- `cur` = 以 i 结尾的合法子数组数量
    

---

### 2️⃣ 等差子数组（LeetCode 413）

条件：

```text
nums[i] - nums[i-1] == nums[i-1] - nums[i-2]
```

代码骨架：

```go
cur := 0
for i := 2; i < n; i++ {
    if nums[i]-nums[i-1] == nums[i-1]-nums[i-2] {
        cur++
    } else {
        cur = 0
    }
    ans += cur
}
```

**关键点：**

- 这里 `cur` 代表：
    
    - 以 `i` 结尾、长度 ≥ 3 的等差子数组数量
        

---

### 3️⃣ 连续递增 / 连续相等 / 连续满足条件

#### 连续递增子数组个数

条件：

```text
nums[i] > nums[i-1]
```

```go
cur := 0
for i := 0; i < n; i++ {
    if i > 0 && nums[i] > nums[i-1] {
        cur++
    } else {
        cur = 1
    }
    ans += cur
}
```

---

## 三、什么时候**一定**可以用压缩 DP？

你可以用下面 3 个判断来自检：

✅ 条件只依赖于 **前 1～2 个位置**  
✅ 只统计 **连续区间**  
✅ 问的是「子数组 / 子区间数量」

只要满足这三条，**优先考虑 `cur` 模型**。

---

## 四、常见坑

### ❌ 误区 1：还在纠结「子数组枚举」

> 连续段问题 **99% 不需要双重循环**

---

### ❌ 误区 2：`cur` 的初始值错了

- 有的题：`cur = 1`
    
- 有的题：`cur = 0`
    

**判断标准：**

> `cur` 表示的东西，在条件刚成立时应不应该计数？

---

### ❌ 误区 3：想一次性覆盖所有情况

压缩 DP 的精髓是：

> **只关心“以 i 结尾”**

不是全局最优，不是最长，只是结尾。

---

## 五、给你的“心法一句话”

> **连续段问题，不想区间，只想“我现在接上了多少”。**

这句话在你以后刷题时会反复出现。

---

