
## 🧠 Fenwick 树是什么？

它是一种数据结构，用来快速维护 **前缀和** 或 **频率统计**。

支持两种核心操作：

|操作|含义|时间复杂度|
|---|---|---|
|`add(i, x)`|单点增加|O(log n)|
|`sum(i)`|查询区间 `[1, i]` 的和|O(log n)|

相比普通数组：

|方法|修改|查询前缀和|
|---|---|---|
|普通数组扫|O(1)|O(n)|
|前缀和数组|O(n)|O(1)|
|**Fenwick 树**|**O(log n)**|**O(log n)**|

👉 优势：动态修改 + 快速查询都能兼顾

---

## ⛓ 基本思想（核心记一句）

> 用二进制最低位 lowbit(i) 控制节点覆盖大小  
> `lowbit(i) = i & (-i)`

例：  
i = 6 = 110₂  
lowbit = 2  
因此 `tree[6]` 负责长度为 2 的区域  
覆盖 `[5, 6]`

| i   | 二进制  | lowbit(i) | 覆盖区间   |
| --- | ---- | --------- | ------ |
| 4   | 100  | 4         | [1, 4] |
| 6   | 110  | 2         | [5, 6] |
| 8   | 1000 | 8         | [1, 8] |

这构成了一个 **多区间重叠的存储结构**。

---

## ✍️ Fenwick 树模板（务必记住）

```cpp
struct Fenwick {
    int n;
    vector<long long> tree;
    Fenwick(int n):n(n),tree(n+1,0) {}

    // 单点增加
    void add(int i, long long v) {
        for (; i <= n; i += i & -i) {
            tree[i] += v;
        }
    }

    // 查询前缀和 [1..i]
    long long sum(int i) {
        long long s = 0;
        for (; i > 0; i -= i & -i) {
            s += tree[i];
        }
        return s;
    }

    long long range(int l, int r) {
        return sum(r) - sum(l - 1);
    }
};
```

记忆要点：

|行为|遍历方向|变化量|
|---|---|---|
|add|往上跳|`i += lowbit(i)`|
|sum|往下跳|`i -= lowbit(i)`|

---

## 🔍 为什么这样遍历？

假设 i = 13 (1101₂)  
lowbit = 1  
sum 查询路径：

```
sum(13)
= tree[13] + tree[12] + tree[8]
```

范围被拆成多个易计算块，  
块数量 = 二进制位个数 → O(log n)




|序号|关键认知|
|---|---|
|1|Fenwick 树用于维护「动态前缀和/频率」|
|2|`lowbit(i)` 决定节点区间大小（非常重要）|
|3|修改向上跳(`+= lowbit`)；查询向下跳(`-= lowbit`)|
|4|所有操作都能在 `O(log n)` 完成|

---



# ⭐️ lowbit(i) 到底是什么？

定义：

> `lowbit(i) = i & (-i)`  
> 作用：取出 i 的**二进制表示中最右边的 1**

例：

```
i = 6 = 0110₂
-6 = 010₂（按补码规则 = 1010? 不用深究）
&  运算结果：
110
010
---
010 = 2
```

👉 所以 lowbit(6) = 2  
表示 `tree[6]` 这节点负责 **长度为2的区间**。

---

# ⭐️ 那区间的起点怎么知道？

公式：

> `Fenwick树每个节点 i 负责一个区间 [i - lowbit(i) + 1, i]`

代入：

```
i = 6
lowbit = 2
start = 6 - 2 + 1 = 5
区间 = [5, 6]
```

这就是为什么 `tree[6]` 负责 `[5,6]`

---

## 再举两个巩固例子：

| i   | 二进制  | lowbit | 覆盖区间解释  |
| --- | ---- | ------ | ------- |
| 4   | 100  | 4      | [1,4]   |
| 7   | 111  | 1      | [7,7]   |
| 12  | 1100 | 4      | [9,12]  |
| 14  | 1110 | 2      | [13,14] |

---

# 🤔 为什么是这种结构？

这是整棵结构构建的灵魂：

|i|lowbit|区间长度|扮演角色|
|---|---|---|---|
|是 2 的幂（如 4,8,16）|大|负责大区间|大区间总和|
|末尾是小数字（如 6,14）|小|补细小区间|精准补充|

所以：

- sum 时 **往下跳**，区间会越来越大，快速覆盖 `[1..i]`
    
- add 时 **往上跳**，影响越来越大范围的区块
    

这就是为何所有操作都 O(log n)

---

# ✨ 用一句话总结：

> `lowbit(i)` = Fenwick 树每个节点负责的区间长度  
> `i - lowbit(i) + 1` = 该区间的起始位置

---





## 🔹回顾核心思想

Fenwick 树 存的是 **一段区间的和**，区间长度由 `lowbit(i)` 决定：

> `tree[i]` 负责 `[ i - lowbit(i) + 1 , i ]` 这一段 🎯

而我们实际维护的是：

- **更新**：某个位置 `pos += val`
    
- **查询前缀和**：`sum = nums[1] + nums[2] + ... + nums[pos]`
    

---

## 🔸更新操作（add）

当我们在位置 `pos` 加 val：

```cpp
void add(int pos, int val) {
    for (; pos < N; pos += pos & -pos) {
        tree[pos] += val;
    }
}
```

为什么是 `+= lowbit(pos)` 往上走？  
因为上层节点负责的区间更大，需要同步更新 ⬆️

📌例：pos = 6  
lowbit(6)=2 → update 6  
6 += 2 → 8 → update 8  
8 += 8 → 16 → update 16  
...直到超出范围

---

## 🔸查询前缀和（sum）

```cpp
int sum(int pos) {
    int res = 0;
    for (; pos > 0; pos -= pos & -pos) {
        res += tree[pos];
    }
    return res;
}
```

为什么是 `-= lowbit(pos)`❓  
因为每个节点已经囊括一段区间，所以可以直接跳过去取整个区间 📦

📌例：pos = 6  
lowbit(6)=2 → sum += tree[6]  
6-2=4 → sum += tree[4]  
4-4=0 → 停止  
这恰好拼成 `[1..6]` 的前缀和 🎯

---

## 🌟总结口诀

|操作|公式|跳转方向|
|---|---|---|
|**更新 add**|`i += lowbit(i)`|往 **上** 更新更大区间|
|**查询 sum**|`i -= lowbit(i)`|往 **下** 收集分段区间|


