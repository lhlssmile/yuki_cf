
### 1. 子树和是什么？**
- **树**：一棵有根的树（比如根在1号节点），每个节点有孩子。
- **子树和**：对于节点u，它的子树包括u自己和所有后代节点的值之和。简单DFS就能算：`sum[u] = val[u] + sum(child1) + sum(child2) + ...`
- 但如果题目要**查询很多次**子树和，或者树很大（n=1e5），纯DFS每次O(n)太慢。这时就需要**前缀和**优化！

**为什么用前缀和？** 树不是线性结构，但我们可以把树“展平”成一条线，用前缀和O(1)查区间和～核心技巧：**Euler Tour（欧拉遍历） + DFS时间戳 + 前缀和数组**。

### 2. **核心技巧：Euler Tour + Prefix Sum**

- 展平：对每个节点记录进入时间 `tin[u]` 与离开时间 `tout[u]`（离开时刻的下一个格）。
- 子树区间：`u` 的子树恰好对应线性序列区间 `[tin[u], tout[u]-1]`。
- 这样就把树问题转成区间问题，可以用前缀和、差分、Fenwick树、线段树处理。

### 3. Fenwick Tree（树状数组）直观理解
- `t[i]` 保存了一个“以 `i` 为尾的某段区间”的累计值，区间长度是 `lowbit(i)`，其中 `lowbit(i) = i & -i` 是 `i` 的二进制最低位的 1 所代表的数。
- `add(i, v)`：把位置 `i` 的值增加 `v`，并向上更新所有“覆盖到 `i` 的区间块”。上跳规则是 `i += lowbit(i)`，因此复杂度 `O(log n)`。
- `sum(i)`：求区间 `[1..i]` 的前缀和。每次把当前块的值加到答案里，然后下跳到前一个块：`i -= lowbit(i)`，复杂度 `O(log n)`。
- 为什么不是“遍历孩子”？Fenwick 的结构是“基于索引的二进制分块”，`add` 和 `sum` 都是在分块树的祖先/前缀块之间跳跃，不直接遍历图上的孩子。

### 4. 区间加 + 单点查（差分思想）
- 经典差分：若要对区间 `[L, R]` 加 `delta`，只需 `diff[L] += delta`、`diff[R+1] -= delta`，则任一点 `x` 的值就是前缀和 `prefix(x)`。
- Fenwick 可以存这个差分 `diff`，用 `add(L, delta)` 和 `add(R+1, -delta)` 实现区间加，查询点值用 `sum(x)`。
- 应用到树：对子树 `u` 加，区间就是 `[tin[u], tout[u]-1]`，因此做 `add(tin[u], delta)` 和 `add(tout[u], -delta)`，查询节点 `v` 的当前值就是 `sum(tin[v])`。

### 5. CF383C 的“交替符号”
- 题意中的更新是“从节点 `u` 出发，沿深度奇偶交替 +w/-w/...”。
- 用一个符号函数 `s[u] = (+1)` 当 `dep[u]` 是偶数，否则 `-1`。
- 把题目要求转成：给 `u` 子树区间加 `delta = w * s[u]`，查询节点 `v` 的当前值为 `a[v] + s[v] * path_sum[v]`，其中 `path_sum[v] = sum(tin[v])` 是所有祖先更新在 `v` 的叠加量。
- 这样，把“交替加减”的复杂性全都通过 `s[u]` 的符号一次性解决。

### 6. 和代码的对应关系
- 扁平化与深度：`tin/tout/dep` 在迭代 DFS 中一次性求出（参见 `cf383.cpp:35-54`）。
- Fenwick 树：`add(i, v)` 与 `sum(i)` 的实现（参见 `cf383.cpp:56-59`）。
- 更新操作：`add(tin[u], w * s[u])` 与 `add(tout[u], -w * s[u])`（参见 `cf383.cpp:60-63`）。
- 查询操作：`a[u] + s[u] * sum(tin[u])`（参见 `cf383.cpp:64-66`）。

### 7. 一句话记忆
- 树问题 → Euler 展平 → 子树变区间。
- 区间加/点查 → Fenwick 存差分 → `[L, R]` 用 `+delta`、`-(R+1)`。
- 交替加减 → 乘上 `s[u] = (-1)^{dep[u]}`，查询时再乘 `s[v]` 还原真实值。
