

### application


**1. calculate F(n)**

用 **二进制幂 + 矩阵** 来快速算一个 **斐波那契数** 

---

#### 问题：用二进制幂快速计算第 `n` 个斐波那契数

我们想算：**`F(10)`**，也就是第 10 个斐波那契数。

> 斐波那契数列：  
> `F(0) = 0, F(1) = 1`  
> `F(n) = F(n-1) + F(n-2)`

---

#### 关键思路：用矩阵表示递推！

我们知道：

```
[ F(n)   ]   =   [ F(n-1) ]
[ F(n-1) ]   =   [ F(n-2) ]
```

可以写成矩阵形式：

```
| F(n)   |   =   | 1 1 |   ×   | F(n-1) |
| F(n-1) |       | 1 0 |       | F(n-2) |
```

所以，**转移矩阵 M =**

```
| 1 1 |
| 1 0 |
```

那么：

```
| F(n)   |   =   M^(n-1)   ×   | F(1) |
| F(n-1) |                     | F(0) |
```

更进一步：

```
| F(n)   |   =   M^n   ×   | F(0) |
| F(n-1) |                 | F(1) |
```

但注意：`F(0)=0, F(1)=1`，所以我们可以从 `n=0` 开始推。

更常用的是：

```
| F(n+1) |   =   M^n   ×   | F(1) |
| F(n)   |                 | F(0) |
```

我们用这个！

---

#### 我们要算 F(10)，所以需要 M^10

初始向量是：

```
| F(1) |   =   | 1 |
| F(0) |       | 0 |
```

所以：

```
| F(11) |   =   M^10   ×   | 1 |
| F(10) |                  | 0 |
```

我们只需要算出 `M^10`，再乘这个向量，取下面那个数就是 `F(10)` 喵！

---

#### 步骤 1：定义矩阵乘法（模版）

我们用 2×2 矩阵，用二进制幂来快速算 `M^10`

---

#### 步骤 2：手算 M^10（用二进制幂）

`10` 的二进制是：`1010₂` = 8 + 2 = 10

我们从 `res = I`（单位矩阵）开始，`base = M`

```
M = | 1 1 |
    | 1 0 |
```

##### 循环过程：

| b (剩余)    | b & 1 ? | res 更新         | base = base × base | b >>= 1 |
| --------- | ------- | -------------- | ------------------ | ------- |
| 10 (1010) | 0       | res 不变         | base = M²          | b=5     |
| 5 (0101)  | 1       | res = res × M² | base = (M²)² = M⁴  | b=2     |
| 2 (0010)  | 0       | res 不变         | base = M⁸          | b=1     |
| 1 (0001)  | 1       | res = res × M⁸ | base = M¹⁶         | b=0     |

---

##### 计算过程（手算）：

1. **M¹ =** `|1 1|`  
	    `|1 0|`

2. **M² = M × M =**

```
|1 1| × |1 1| = |2 1|
|1 0|   |1 0|   |1 1|
```

3. **M⁴ = M² × M² =**

```
|2 1| × |2 1| = |5 3|
|1 1|   |1 1|   |3 2|
```

4. **M⁸ = M⁴ × M⁴ =**

```
|5 3| × |5 3| = |34 21|
|3 2|   |3 2|   |21 13|
```

---

##### 回代 res：

- 初始：`res = I = |1 0|`
                             `|0 1|`

- b=10 → 不乘
- b=5 → 乘 M² → `res = |2 1|`
                     `|1 1|`
- b=2 → 不乘
- b=1 → 乘 M⁸ → `res = |2 1| × |34 21| = |89  55|`
                     `|1 1|   |21 13|   |55  34|`

---

#### 最终：M^10 = 

```
| 89  55 |
| 55  34 |
```

---

#### 最后一步：乘初始向量

```
| F(11) |   =   M^10   ×   | 1 |   =   |89  55| × |1|   =   |89|
| F(10) |               | 0 |       |55  34|   |0|       |55|
```

所以：**`F(10) = 55`** 喵！

---

#### 验证斐波那契数列：

```
F(0)=0
F(1)=1
F(2)=1
F(3)=2
F(4)=3
F(5)=5
F(6)=8
F(7)=13
F(8)=21
F(9)=34
F(10)=55  ← 正确！
```

---

#### 总结：完整流程喵！

```cpp
// 矩阵结构体 + 乘法 + 二进制幂
struct Matrix {
    long long m[2][2];
    Matrix() { memset(m, 0, sizeof(m)); }
};

Matrix mul(Matrix a, Matrix b) {
    Matrix c;
    for(int i=0; i<2; i++)
        for(int j=0; j<2; j++)
            for(int k=0; k<2; k++)
                c.m[i][j] += a.m[i][k] * b.m[k][j];
    return c;
}

Matrix pow(Matrix a, long long n) {
    Matrix res; // 单位矩阵
    res.m[0][0] = res.m[1][1] = 1;
    while(n) {
        if(n & 1) res = mul(res, a);
        a = mul(a, a);
        n >>= 1;
    }
    return res;
}

long long fib(long long n) {
    if(n == 0) return 0;
    Matrix M;
    M.m[0][0] = M.m[0][1] = M.m[1][0] = 1;
    M.m[1][1] = 0;
    Matrix res = pow(M, n);
    return res.m[1][0]; // F(n)
}
```

调用 `fib(10)` → 返回 `55`

---

- 这个方法可以算 **超大 n** 的斐波那契（比如 `n=10^18`），只要矩阵乘法用 `long long` 就行（或模 1e9+7）
- 时间复杂度：**O(log n)**，超快喵！

---



**2.Applying a permutations k times**

**“Applying a permutation k times”**（把一个排列重复作用 k 次）！

---

#### 问题是什么？

> 给你一个长度为 `n` 的序列（比如数组 `[0, 1, 2, 3]`）  
> 还有一个**排列 `p`**，表示每个位置 `i` 应该映射到 `p[i]`  
> 你要**把这个排列作用 k 次**，得到最终序列

---

##### 举个例子喵！

```text
初始序列： [A, B, C, D]   ← 位置 0,1,2,3
排列 p   ： [2, 0, 3, 1]   ← 意思是：
       位置0 → 位置2
       位置1 → 位置0
       位置2 → 位置3
       位置3 → 位置1
```

作用一次：

```
新序列[0] = 旧序列[p[0]] = 旧序列[2] = C
新序列[1] = 旧序列[p[1]] = 旧序列[0] = A
新序列[2] = 旧序列[p[2]] = 旧序列[3] = D
新序列[3] = 旧序列[p[3]] = 旧序列[1] = B
```

结果：`[C, A, D, B]`

---

#### 如果 k 很大？比如 k = 1e18？

不能循环 k 次！太慢了 → O(n × k) = 爆炸！

所以我们要用 **二进制幂** 来加速！

---

#### 关键思路：**排列也可以“乘”！**

就像：

> 矩阵 × 矩阵 = 复合变换  
> **排列 × 排列 = 复合映射**

我们把 `p` 看成一个“变换函数”，作用两次就是 `p²`，作用 k 次就是 `p^k`

---

#### 怎么用二进制幂算 `p^k`？

用和矩阵一模一样的思路！

```cpp
while (k > 0) {
    if (k & 1)
        sequence = apply(sequence, p);  // res *= p
    p = apply(p, p);                    // p = p * p
    k >>= 1;
}
```

但注意：这里 `apply(A, B)` 的意思是：

> 把排列 `B` 作用在序列 `A` 上，得到新序列

---

#### 代码详解（文档里的）

```cpp
vector<int> applyPermutation(vector<int> sequence, vector<int> permutation) {
    vector<int> newSequence(sequence.size());
    for(int i = 0; i < sequence.size(); i++) {
        newSequence[i] = sequence[permutation[i]];
    }
    return newSequence;
}

vector<int> permute(vector<int> sequence, vector<int> permutation, long long k) {
    while (k > 0) {
        if (k & 1) {
            sequence = applyPermutation(sequence, permutation);
        }
        permutation = applyPermutation(permutation, permutation);
        k >>= 1;
    }
    return sequence;
}
```

---

#### 举个完整例子：k=3

```text
初始：sequence = [A, B, C, D]
       permutation = [2, 0, 3, 1]
       k = 3 (二进制 11)
```

| k | k&1 | sequence 更新 | permutation 更新 | k >>=1 |
|---|-----|---------------|------------------|--------|
| 3 | 1   | `sequence = apply(sequence, p)` → `[C,A,D,B]` | - | - |
| - | -   | - | `p = apply(p, p)` → 计算 p² | - |
| 1 | 1   | `sequence = apply(sequence, p²)` | - | 0 |

---

##### 计算 p²：

```text
p = [2,0,3,1]
p²[i] = p[p[i]]

p²[0] = p[2] = 3
p²[1] = p[0] = 2
p²[2] = p[3] = 1
p²[3] = p[1] = 0
```

所以 `p² = [3,2,1,0]`

---

##### 再作用一次 p²：

```text
当前 sequence = [C, A, D, B]
新序列[i] = 旧序列[p²[i]]

新[0] = 旧[3] = B
新[1] = 旧[2] = D
新[2] = 旧[1] = A
新[3] = 旧[0] = C
```

最终：`[B, D, A, C]`

---

#### 验证：手动作用 3 次

```
初始：[A,B,C,D]
1次 ：[C,A,D,B]
2次 ：[D,C,B,A]
3次 ：[B,D,A,C]  ← 完全一致！
```

---

#### 时间复杂度？

- 每次 `apply` 是 O(n)
- 二进制幂循环 O(log k) 次
- 总共：**O(n log k)**

比 O(n×k) 快亿倍！

---

#### 更优解？（文档有说）

> **可以用「换位循环」优化到 O(n)**

### 思路：

排列会形成若干**循环**（cycle）

比如：

```text
0 → 2 → 3 → 1 → 0   ← 长度4的环
```

作用 k 次 = 在环内前进 k 步 = `k % 环长`

所以：

1. 拆出所有环
2. 对每个环，计算 `k % len`
3. 重新排列

→ **O(n)**，一次遍历搞定！

但**二进制幂更通用**，容易套模板！

---

#### 总结：这个应用的核心

| 概念 | 说明 |
|------|------|
| 排列作用 | `new[i] = old[p[i]]` |
| 排列复合 | `p²[i] = p[p[i]]` |
| k次作用 | `p^k`，用二进制幂算 |
| 复杂度 | **O(n log k)** |
| 更优 | 换位循环 → O(n) |

---


**4. 有向无权图的k条path**

哈哈哈喵！好的好的～**完全切换中文模式**！  
我们来把 **“图中长度为 k 的路径条数”** 这个应用，**从头到尾讲得明明白白**！

---

#### 问题是什么？

> 给你一个 **有向图**，有 `n` 个点（编号 0 ~ n-1）  
> 边没有权重，就是 **0/1**（有边 or 没边）  
> 给你一个大整数 `k`（比如 `1e18`）  
>
> **问：从点 `u` 到点 `v`，恰好走 `k` 条边，有多少种走法？**  
> 要输出 **所有 u→v 的答案**（n×n 个数）

---



#### 神奇思路：**邻接矩阵的 k 次方！**

##### 定义邻接矩阵 `A`（n×n）：

```
A[i][j] = 1  如果 i → j 有一条边
A[i][j] = 0  否则
```

比如：

```
点：0,1,2
边：0→1, 1→2, 2→0
```

邻接矩阵 `A`：

```
  0 1 2
0 0 1 0
1 0 0 1
2 1 0 0
```

---

#### 重磅定理：

> **A^k [i][j] = 从 i 到 j 恰好走 k 步的路径条数！**

---

#### 为什么是对的？

##### 看 `A² = A × A`：

```
(A²)[i][j] = Σ A[i][k] * A[k][j]
           = 所有中间点 k，满足 i→k 且 k→j 的数量
           = 从 i 走 2 步到 j 的路径数
```

同理：

```
A^k[i][j] = 从 i 走 k 步到 j 的方案数
```

---

#### 我们要算：**`A^k`**

- 矩阵乘法满足**结合律** → 可以用 **二进制幂**！
- 时间：**O(n³ log k)**  
  - 一次矩阵乘：`O(n³)`
  - 二进制幂：`O(log k)` 次

---


#### 代码模板

```cpp
using ll = long long;
const int N = 105;
ll mod = 1e9+7; // 如果要取模

struct Matrix {
    ll a[N][N];
    int n;
    Matrix(int _n) : n(_n) { memset(a, 0, sizeof(a)); }
};

Matrix mul(const Matrix& A, const Matrix& B) {
    Matrix C(A.n);
    for(int i=0; i<A.n; i++)
        for(int j=0; j<A.n; j++)
            for(int k=0; k<A.n; k++) {
                C.a[i][j] = (C.a[i][j] + A.a[i][k] * B.a[k][j]) % mod;
            }
    return C;
}

Matrix pow(Matrix A, ll k) {
    Matrix res(A.n);
    for(int i=0; i<A.n; i++) res.a[i][i] = 1; // 单位矩阵
    while(k) {
        if(k & 1) res = mul(res, A);
        A = mul(A, A);
        k >>= 1;
    }
    return res;
}
```

使用：

```cpp
int n = 3;
Matrix adj(n);
// 建图
adj.a[0][1] = 1;
adj.a[1][2] = 1;
adj.a[2][0] = 1;

Matrix Ak = pow(adj, 3);
cout << Ak.a[0][0] << endl; // 输出 1
```

---

#### 进阶：**带权图 + 求「最小权路径」**

文档也说了：

> 边有权重 → 求「恰好 k 条边的最小权和」

##### 改两点：

1. `A[i][j] = 边权`（无边 = `INF`）
2. 矩阵乘法改成：
   ```
   C[i][j] = min over k ( A[i][k] + B[k][j] )
   ```

→ 变成 **矩阵的「加法+min」版本** 的二进制幂

---

#### 总结：这个应用解决什么？

| 项目 | 内容 |
|------|------|
| 问题 | 统计「从 u 到 v 恰好走 k 步」的路径数 |
| 工具 | 邻接矩阵 `A` |
| 核心 | `A^k[i][j] = 答案` |
| 加速 | 矩阵二进制幂 |
| 复杂度 | **O(n³ log k)** |
| 适用 | k 超大、n ≤ 100 |

---

